

================================================================================
FILE PATH: .\.gitignore
================================================================================


target/



================================================================================
FILE PATH: .\LICENSE.md
================================================================================


# Tawny License

Copyright (c) 2025 Tawny

Permission is hereby granted to any individual or organization to use, modify, redistribute, or resell this software, provided that the following conditions are met:

1. **Credit**  
   Proper credit must be given to **Tawny** as the original author in any distributed or derivative works.

2. **Public Forks**  
   Any fork, modification, or derivative of this project must remain **publicly accessible**.  
   Private forks or closed-source redistributions are not allowed.

3. **License Inclusion**  
   This license file must be included, unaltered, in all copies or redistributions.

4. **Liability**  
   This software is provided ‚Äúas is,‚Äù without warranty of any kind.  
   The author is not liable for any damages, data loss, or issues resulting from its use.

---

**Summary:**  
You may use, modify, and sell this project, but you must credit **Tawny**, keep forks public, and include this license.



================================================================================
FILE PATH: .\pom.xml
================================================================================


<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>ret.tawny</groupId>
    <artifactId>truthful</artifactId>
    <version>v1.2</version>
    <packaging>jar</packaging>

    <name>Truthful</name>

    <description>An advanced anticheat updated for modern Minecraft servers</description>
    <properties>
        <java.version>17</java.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <release>${java.version}</release>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.5.1</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <createDependencyReducedPom>false</createDependencyReducedPom>
                            <relocations>
                                <!-- Relocate bStats to prevent conflicts with other plugins -->
                                <relocation>
                                    <pattern>org.bstats</pattern>
                                    <shadedPattern>ret.tawny.truthful.bstats</shadedPattern>
                                </relocation>
                            </relocations>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>true</filtering>
            </resource>
        </resources>
    </build>

    <repositories>
        <repository>
            <id>papermc-repo</id>
            <url>https://repo.papermc.io/repository/maven-public/</url>
        </repository>
        <repository>
            <id>sonatype</id>
            <url>https://oss.sonatype.org/content/groups/public/</url>
        </repository>
        <repository>
            <id>dmulloy2-repo</id>
            <url>https://repo.dmulloy2.net/repository/public/</url>
        </repository>
        <repository>
            <id>geysermc-repo</id>
            <url>https://repo.geysermc.org/repository/maven-public/</url>
        </repository>
        <repository>
            <id>opencollab-repo</id>
            <url>https://repo.opencollab.dev/main/</url>
        </repository>
        <repository>
            <id>scarsz-nexus</id>
            <url>https://nexus.scarsz.me/content/groups/public/</url>
        </repository>
        <repository>
            <id>sonatype-snapshots</id>
            <url>https://oss.sonatype.org/content/repositories/snapshots</url>
        </repository>
    </repositories>

    <dependencies>
        <dependency>
            <groupId>io.papermc.paper</groupId>
            <artifactId>paper-api</artifactId>
            <version>1.21-R0.1-SNAPSHOT</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>com.comphenix.protocol</groupId>
            <artifactId>ProtocolLib</artifactId>
            <version>5.3.0</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.reflections</groupId>
            <artifactId>reflections</artifactId>
            <version>0.10.2</version>
        </dependency>
        <dependency>
            <groupId>io.netty</groupId>
            <artifactId>netty-buffer</artifactId>
            <version>4.2.3.Final</version> <!-- Use a version matching your server (4.1.x is standard) -->
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.geysermc.floodgate</groupId>
            <artifactId>api</artifactId>
            <version>2.2.2-SNAPSHOT</version>
            <scope>provided</scope>
        </dependency>
        <!-- bStats Metrics -->
        <dependency>
            <groupId>org.bstats</groupId>
            <artifactId>bstats-bukkit</artifactId>
            <version>3.0.2</version>
            <scope>compile</scope>
        </dependency>
    </dependencies>
</project>


================================================================================
FILE PATH: .\README.md
================================================================================


# ‚ö†Ô∏è **Warning**
> **Do not use this on a production server.**  
> TruthfulAC was originally built for **Minecraft 1.8** and is now being **ported to modern versions**.  
> Expect **bugs, bypasses, or odd behavior** until further testing is complete.

---

## üß© **Community Rules**

1. **No support begging.**  
   > This is a **free anti-cheat** ‚Äî updates and support come when they come.

2. **Pull Requests.**  
   > No **rebranding**, **private forks**, or claiming ownership.

3. **Don‚Äôt complain ‚Äî report.**  
   > If something breaks, **open an issue** instead of creating drama.

---

# üõ°Ô∏è **TruthfulAC**

### Description
Originally written in **2019**, TruthfulAC is being **revived and updated** ‚Äî maintaining **1.8 support** while bringing compatibility to **newer Minecraft versions**.

---

## ‚öôÔ∏è **Current Features**
> ‚ö†Ô∏è Some detections may still have unseen bugs or edge-case behavior.

- Clean, easy-to-read, and well-documented code  
- Core detections: `FlyA`, `SpeedA`, `SpeedB`, `JesusA`, `ScaffoldA‚ÄìG`  
- Supports **multiple Minecraft versions**
   1.8 to 1.21.10

---

## üîÆ **Planned Additions**

- Full **GUI interface**  
- Expanded **check library**  
- **Multi-language** support  
- Rewritten **recast system** for accuracy and performance

---

## üí¨ **Support & Community**

Join the Discord for updates, reports, and development chat:  
üëâ [**https://discord.gg/xRchyJFkBG**](https://discord.gg/xRchyJFkBG)



================================================================================
FILE PATH: .\truthful.iml
================================================================================


<?xml version="1.0" encoding="UTF-8"?>
<module version="4">
  <component name="FacetManager">
    <facet type="minecraft" name="Minecraft">
      <configuration>
        <autoDetectTypes>
          <platformType>PAPER</platformType>
        </autoDetectTypes>
        <projectReimportVersion>1</projectReimportVersion>
      </configuration>
    </facet>
  </component>
</module>


================================================================================
FILE PATH: .\.vscode\settings.json
================================================================================


{
    "java.compile.nullAnalysis.mode": "automatic"
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\Truthful.java
================================================================================


package ret.tawny.truthful;

import org.bukkit.Bukkit;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Player;
import org.bukkit.entity.Vehicle;
import org.bukkit.plugin.Plugin;
import org.bukkit.scheduler.BukkitRunnable;
import org.geysermc.floodgate.api.FloodgateApi;
import ret.tawny.truthful.checks.registry.CheckRegistry;
import ret.tawny.truthful.commands.impl.CommandManager;
import ret.tawny.truthful.compensation.CompensationTracker;
import ret.tawny.truthful.compensation.Scheduler;
import ret.tawny.truthful.config.api.Configuration;
import ret.tawny.truthful.data.DataManager;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.database.LogManager;
import ret.tawny.truthful.gui.GuiManager;
import ret.tawny.truthful.listener.PacketListener;
import ret.tawny.truthful.listener.PlayerListener;
import ret.tawny.truthful.version.VersionManager;

public final class Truthful {
    private static final Truthful INSTANCE = new Truthful();

    private boolean floodgateSupportEnabled = false;
    private FloodgateApi floodgateApi = null;

    private VersionManager versionManager;
    private CheckRegistry checkManager;
    private DataManager dataManager;
    private Scheduler scheduler;
    private CompensationTracker compensationTracker;
    private PlayerListener playerListener;
    private PacketListener packetListener;
    private LogManager logManager;
    private GuiManager guiManager;
    private Plugin plugin;

    private Truthful() {}

    public void start(final Plugin plugin) {
        this.plugin = plugin;

        if (Bukkit.getPluginManager().isPluginEnabled("floodgate")) {
            try {
                this.floodgateApi = FloodgateApi.getInstance();
                this.floodgateSupportEnabled = true;
                plugin.getLogger().info("Successfully hooked into Floodgate.");
            } catch (Exception e) {
                plugin.getLogger().warning("Found Floodgate, but failed to hook.");
            }
        }

        this.versionManager = new VersionManager();
        this.dataManager = new DataManager();
        this.scheduler = new Scheduler();
        this.logManager = new LogManager(plugin);
        this.guiManager = new GuiManager();

        this.versionManager.load();
        this.compensationTracker = new CompensationTracker();

        plugin.getServer().getPluginCommand("truthful").setExecutor(new CommandManager());

        this.checkManager = new CheckRegistry();
        this.playerListener = new PlayerListener();
        this.packetListener = new PacketListener(this.checkManager);

        this.checkManager.init();

        // --- SYNC TASK LOOP ---
        new BukkitRunnable() {
            @Override
            public void run() {
                // 1. Tick Compensation Tracker
                if (compensationTracker != null) {
                    compensationTracker.tick();
                }

                // 2. Update Thread-Safe Entity Data for Checks
                for (Player player : Bukkit.getOnlinePlayers()) {
                    PlayerData data = dataManager.getPlayerData(player);
                    if (data == null) continue;

                    boolean vehicleNearby = false;
                    boolean entityNearby = false;

                    // Scan for entities in a 1.5 block radius (generous to prevent falses)
                    // Added Entity Type checks to avoid casting unnecessary entities
                    for (Entity entity : player.getNearbyEntities(1.5, 1.5, 1.5)) {
                        if (entity instanceof Vehicle) {
                            vehicleNearby = true;
                        } else if (entity instanceof Player || entity.getType().isAlive()) {
                            // Any other living entity or player
                            entityNearby = true;
                        }
                    }

                    data.setNearVehicle(vehicleNearby);
                    data.setNearEntity(entityNearby);
                }
            }
        }.runTaskTimer(plugin, 1L, 1L);
    }

    public void shutdown() {
        if (logManager != null) {
            logManager.shutdown();
        }
    }

    public boolean isBedrockPlayer(Player player) {
        if (!floodgateSupportEnabled || floodgateApi == null || player == null) {
            return false;
        }
        try {
            return floodgateApi.isFloodgatePlayer(player.getUniqueId());
        } catch (Exception e) {
            return false;
        }
    }

    public static Truthful getInstance() { return INSTANCE; }
    public VersionManager getVersionManager() { return this.versionManager; }
    public DataManager getDataManager() { return this.dataManager; }
    public CheckRegistry getCheckManager() { return this.checkManager; }
    public Configuration getConfiguration() { return ((TruthfulPlugin) plugin).getConfiguration(); }
    public Plugin getPlugin() { return plugin; }
    public PlayerListener getPlayerListener() { return playerListener; }
    public Scheduler getScheduler() { return scheduler; }
    public CompensationTracker getCompensationTracker() { return compensationTracker; }
    public LogManager getLogManager() { return logManager; }
    public GuiManager getGuiManager() { return guiManager; }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\TruthfulPlugin.java
================================================================================


// FILE PATH: .\src\main\java\ret\tawny\truthful\TruthfulPlugin.java

package ret.tawny.truthful;

import org.bstats.bukkit.Metrics;
import org.bukkit.plugin.java.JavaPlugin;
import ret.tawny.truthful.config.api.Configuration;

public final class TruthfulPlugin extends JavaPlugin {
    private Configuration configuration;

    @Override
    public void onEnable() {
        this.configuration = new Configuration(this);

        // Initialize bStats
        // REPLACE 12345 WITH YOUR REAL PLUGIN ID FROM bStats.org
        int pluginId = 28120;
        new Metrics(this, pluginId);

        Truthful.getInstance().start(this);
    }

    @Override
    public void onDisable() {
        Truthful.getInstance().shutdown();
    }

    public Configuration getConfiguration() {
        return configuration;
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\api\Check.java
================================================================================


package ret.tawny.truthful.checks.api;

import com.comphenix.protocol.events.PacketEvent;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.event.Listener;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

public abstract class Check implements Listener {
    private final char order;
    private final CheckType checkType;
    private final String formattedName;
    private final boolean enabled;

    // Cooldown map to prevent infinite teleport loops (Client vs Server fighting)
    private static final Map<UUID, Long> teleportCooldowns = new ConcurrentHashMap<>();

    protected Check() {
        final CheckData checkData = this.getClass().getAnnotation(CheckData.class);
        this.order = checkData.order();
        this.checkType = checkData.type();
        this.formattedName = this.checkType.getName(this);
        this.enabled = Truthful.getInstance().getConfiguration().isCheckEnabled(this.checkType.name(), String.valueOf(this.order));

        if (this.enabled) {
            Bukkit.getPluginManager().registerEvents(this, Truthful.getInstance().getPlugin());
        }
    }

    protected void flag(final PlayerData player, final String debug) {
        if (player.isExempt()) return;

        int vl = player.increment();
        String message = String.format("¬ß8[¬ßcTruthful¬ß8] ¬ßc%s ¬ßffailed ¬ßc%s ¬ß8(¬ßfVL:%s¬ß8) ¬ß7%s",
                player.getPlayer().getName(), this.formattedName, vl, debug);

        Bukkit.getScheduler().runTask(Truthful.getInstance().getPlugin(), () -> {
            Player p = player.getPlayer();
            if (!p.isOnline()) return;

            Bukkit.getLogger().info(p.getName() + " failed " + this.formattedName + ": " + debug);

            for (final Player staff : Bukkit.getOnlinePlayers()) {
                if (staff.hasPermission("truthful.alerts")) {
                    staff.sendMessage(message);
                }
            }

            if (Truthful.getInstance().getConfiguration().isLagbacks()) {
                if (checkType == CheckType.SPEED || checkType == CheckType.FLY ||
                        checkType == CheckType.JESUS || checkType == CheckType.ELYTRA) {

                    if (p.isDead()) return; // Don't teleport dead players

                    long now = System.currentTimeMillis();
                    long lastTeleport = teleportCooldowns.getOrDefault(p.getUniqueId(), 0L);

                    // Only teleport max 5 times a second (200ms cooldown)
                    // This allows the client time to accept the packet before we send another
                    if (now - lastTeleport > 200) {
                        p.teleport(player.getLastLocation());
                        teleportCooldowns.put(p.getUniqueId(), now);
                    }
                }
            }
        });

        Truthful.getInstance().getLogManager().log(
                player.getPlayer().getUniqueId(),
                player.getPlayer().getName(),
                this.formattedName,
                vl,
                player.getPing(),
                debug
        );
    }

    public final char getOrder() { return this.order; }
    public final String getFormattedName() { return this.formattedName; }
    public final boolean isEnabled() { return this.enabled; }

    public void onPacketPlaySend(PacketEvent event) {
        if (shouldCheck(event.getPlayer())) handlePacketPlaySend(event);
    }

    public void onPacketPlayerReceive(PacketEvent event) {
        if (shouldCheck(event.getPlayer())) handlePacketPlayerReceive(event);
    }

    public void onRelMove(RelMovePacketWrapper event) {
        if (shouldCheck(event.getPlayer())) handleRelMove(event);
    }

    private boolean shouldCheck(Player player) {
        if (!enabled || Truthful.getInstance().isBedrockPlayer(player)) return false;
        PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);
        return data != null && !data.isExempt();
    }

    public void handlePacketPlaySend(final PacketEvent event) {}
    public void handlePacketPlayerReceive(final PacketEvent event) {}
    public void handleRelMove(final RelMovePacketWrapper event) {}
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\api\CheckBuffer.java
================================================================================


package ret.tawny.truthful.checks.api;

import org.bukkit.entity.Player;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public final class CheckBuffer {
    private final Map<UUID, Double> bufferMap = new HashMap<>();
    private final double max;

    public CheckBuffer(double max) {
        this.max = max;
    }

    public double increase(Player player, double amount) {
        double current = bufferMap.getOrDefault(player.getUniqueId(), 0.0) + amount;
        bufferMap.put(player.getUniqueId(), current);
        return current;
    }

    public void decrease(Player player, double amount) {
        double current = bufferMap.getOrDefault(player.getUniqueId(), 0.0);
        bufferMap.put(player.getUniqueId(), Math.max(0, current - amount));
    }

    public boolean exceedsMax(Player player) {
        return bufferMap.getOrDefault(player.getUniqueId(), 0.0) > max;
    }

    public void reset(Player player, double value) {
        bufferMap.put(player.getUniqueId(), value);
    }

    public void remove(Player player) {
        bufferMap.remove(player.getUniqueId());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\api\data\CheckData.java
================================================================================


package ret.tawny.truthful.checks.api.data;

import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;

@Retention(RUNTIME)
@Target(TYPE)
public @interface CheckData {
    char order();

    CheckType type();
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\api\data\CheckType.java
================================================================================


package ret.tawny.truthful.checks.api.data;

import ret.tawny.truthful.checks.api.Check;

public enum CheckType {
    FLY("Fly"),
    SPEED("Speed"),
    JESUS("Jesus"),
    SPOOF("Spoof"),
    SPRINT("Sprint"),
    BAD_PACKET("Bad Packet"),
    SCAFFOLD("Scaffold"),
    TIMER("Timer"),
    HITBOX("Hit Box"),
    AIM("Aim"),
    RAYCAST("Raycast"),
    STRAFE("Strafe"),
    ELYTRA("Elytra"),
    PACKET_ORDER("Packet Order"),
    AUTOCLICKER("AutoClicker"),
    REACH("Reach"),
    NO_SLOW("NoSlow"),
    FAST_BREAK("FastBreak");

    private final String name;

    CheckType(final String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }

    public String getName(final Check check) {
        return this.name + (check.getOrder() == ' ' ? "" : "(" + check.getOrder() + ")");
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\badpackets\BadPacketsA.java
================================================================================


package ret.tawny.truthful.checks.impl.badpackets;

import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'A', type = CheckType.BAD_PACKET)
@SuppressWarnings("unused")
public final class BadPacketsA extends Check {

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        if (!relMovePacketWrapper.isRotationUpdate()) {
            return;
        }

        final double pitch = relMovePacketWrapper.getPitch();

        if (Math.abs(pitch) > 90.0D) {
            final PlayerData playerData = Truthful.getInstance().getDataManager().getPlayerData(relMovePacketWrapper.getPlayer());
            if (playerData != null) {
                // Corrected method call
                flag(playerData, "Invalid pitch " + pitch);
            }
        }
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\badpackets\BadPacketsB.java
================================================================================


package ret.tawny.truthful.checks.impl.badpackets;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;

@CheckData(order = 'B', type = CheckType.BAD_PACKET)
@SuppressWarnings("unused")
public final class BadPacketsB extends Check {

    @Override
    public void handlePacketPlayerReceive(final PacketEvent packetEvent) {
        if (!packetEvent.getPacketType().equals(PacketType.Play.Client.HELD_ITEM_SLOT))
            return;

        final PlayerData playerData = Truthful.getInstance().getDataManager().getPlayerData(packetEvent.getPlayer());
        if (playerData == null)
            return;

        // EXEMPTION: Do not check players who have just joined.
        if (playerData.getTicksTracked() < 100) {
            return;
        }

        if (playerData.getCurrentSlot() == playerData.getLastSlot()) {
            flag(playerData, "Invalid Slot Switch (switched to the same slot)");
        }
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\badpackets\BadPacketsD.java
================================================================================


package ret.tawny.truthful.checks.impl.badpackets;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import com.comphenix.protocol.wrappers.EnumWrappers;
import org.bukkit.entity.Player;
import org.bukkit.potion.PotionEffectType;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;

@CheckData(order = 'D', type = CheckType.BAD_PACKET)
@SuppressWarnings("unused")
public final class BadPacketsD extends Check {

    @Override
    public void handlePacketPlayerReceive(final PacketEvent event) {
        if (!event.getPacketType().equals(PacketType.Play.Client.ENTITY_ACTION)) return;

        final Player player = event.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null) return;

        // Don't check creative/flying players as rules are looser
        if (player.isFlying() || player.getAllowFlight()) return;

        // Extract the action
        EnumWrappers.PlayerAction action = event.getPacket().getPlayerActions().readSafely(0);

        if (action == EnumWrappers.PlayerAction.START_SPRINTING) {

            // Check 1: Blindness
            if (player.hasPotionEffect(PotionEffectType.BLINDNESS)) {
                flag(data, "Sprinting while blinded (Impossible Action)");
                // Force stop sprint to prevent advantage
                player.setSprinting(false);
            }

            // Check 2: Hunger
            // Requires 6 food level (3 shanks) to sprint
            // We use 6.0 as a safe float comparison, though getFoodLevel returns int.
            if (player.getFoodLevel() <= 6) {
                flag(data, "Sprinting with low hunger (Impossible Action)");
                player.setSprinting(false);
            }

            // Check 3: OmniSprint (Sprinting while moving backwards)
            // If the player is moving backwards but sends a sprint packet.
            // This relies on the Movement check updating DeltaX/Z, which happens on POSITION packets.
            // Since ENTITY_ACTION can arrive before/after POSITION, this is heuristic.
            // We check if their last movement was primarily backwards.

            // Code Logic:
            // Calculate movement angle vs look angle. If difference > 135 degrees, they are moving backwards.
            // Skipping strict check here to avoid false positives with network lag,
            // but the Hunger/Blindness checks are 100% accurate.
        }
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\badpackets\PacketLimitB.java
================================================================================


package ret.tawny.truthful.checks.impl.badpackets;

import com.comphenix.protocol.events.PacketEvent;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@CheckData(order = 'B', type = CheckType.BAD_PACKET)
@SuppressWarnings("unused")
public final class PacketLimitB extends Check {

    private final CheckBuffer buffer = new CheckBuffer(10.0);
    // Fix: Use a map to track packet counts per player instead of a global variable
    private final Map<UUID, PacketCounter> packetMap = new ConcurrentHashMap<>();

    @Override
    public void handlePacketPlayerReceive(final PacketEvent event) {
        final Player player = event.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null)
            return;

        // --- FIX: JOIN EXEMPTION ---
        // Clients send massive bursts of packets on join (Settings, Recipes, Tags).
        // Ignore packet limits for the first 5 seconds (100 ticks).
        if (data.getTicksTracked() < 100) return;

        PacketCounter counter = packetMap.computeIfAbsent(player.getUniqueId(), k -> new PacketCounter());

        counter.packets++;
        long now = System.currentTimeMillis();

        if (now - counter.lastClear > 1000) {
            // Reset every second
            // Vanilla client ~20-50/s (Join bursts can be 300+).
            // Nuke/Timer/Regen often > 100/s.

            // Limit 80 is generous for normal gameplay
            if (counter.packets > 80) {
                if (buffer.increase(player, 1.0) > 3.0) {
                    flag(data, "Excessive Packets: " + counter.packets + "/s");
                }
            } else {
                buffer.decrease(player, 0.5);
            }
            counter.packets = 0;
            counter.lastClear = now;
        }
    }

    @EventHandler
    public void onQuit(PlayerQuitEvent event) {
        packetMap.remove(event.getPlayer().getUniqueId());
        buffer.remove(event.getPlayer());
    }

    // Simple container for per-player data
    private static class PacketCounter {
        int packets = 0;
        long lastClear = System.currentTimeMillis();
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\badpackets\PacketOrderA.java
================================================================================


package ret.tawny.truthful.checks.impl.badpackets;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import org.bukkit.entity.Player;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;

@CheckData(order = 'A', type = CheckType.PACKET_ORDER)
@SuppressWarnings("unused")
public final class PacketOrderA extends Check {

    private final CheckBuffer buffer = new CheckBuffer(3.0);
    private long lastPlace;

    @Override
    public void handlePacketPlayerReceive(final PacketEvent event) {
        final Player player = event.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null)
            return;

        if (event.getPacketType() == PacketType.Play.Client.BLOCK_PLACE) {
            lastPlace = System.currentTimeMillis();
        } else if (event.getPacketType() == PacketType.Play.Client.FLYING) {
            // If we placed a block, we expect an arm animation or interaction packet
            // shortly before/after.
            // This is a simplified check: ensure we don't place blocks without swinging
            // (NoSwing).
            // Note: Modern clients might send swing *after* place.

            // For this specific check, we'll look for "Post-Place" anomalies.
            // If a player sends a placement packet but no animation packet within a tick,
            // it's suspicious.
            // However, this requires tracking the animation packet.
        }
    }

    // Implementing a simpler "NoSwing" check for attacking/placing
    // This requires listening to ArmAnimation
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\badpackets\TransactionListener.java
================================================================================


package ret.tawny.truthful.checks.impl.badpackets;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import org.bukkit.entity.Player;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;

@CheckData(order = 'C', type = CheckType.BAD_PACKET)
@SuppressWarnings("unused")
public final class TransactionListener extends Check {

    @Override
    public void handlePacketPlayerReceive(final PacketEvent event) {
        if (event.getPacketType() == PacketType.Play.Client.TRANSACTION) {
            final Player player = event.getPlayer();
            final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

            if (data == null)
                return;

            short id = event.getPacket().getShorts().read(0);
            data.handleTransaction(id);
        }
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\combat\aim\AimA.java
================================================================================


package ret.tawny.truthful.checks.impl.combat.aim;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.utils.math.MathHelper;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'A', type = CheckType.AIM)
public final class AimA extends Check {

    private final CheckBuffer buffer = new CheckBuffer(15.0);
    private double lastDeltaPitch;
    private double lastDeltaYaw;

    @Override
    public void handleRelMove(final RelMovePacketWrapper event) {
        if (!event.isRotationUpdate()) return;

        final Player player = event.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null) return;

        final float deltaYaw = Math.abs(data.getDeltaYaw());
        final float deltaPitch = Math.abs(data.getDeltaPitch());

        final double differenceYaw = Math.abs(deltaYaw - this.lastDeltaYaw);
        final double differencePitch = Math.abs(deltaPitch - this.lastDeltaPitch);

        // Smoothing Detection: If difference is tiny but non-zero
        boolean isSmoothed = differenceYaw < 0.01 || differencePitch < 0.01;

        // Requirement: Must be rotating significantly enough to measure
        boolean validRotation = deltaYaw > 1.5 && deltaPitch > 1.5 && deltaPitch < 30.f;

        if (validRotation && !isSmoothed) {

            final double divisorPitch = MathHelper.getGcd(deltaPitch, this.lastDeltaPitch);
            final double divisorYaw = MathHelper.getGcd(deltaYaw, this.lastDeltaYaw);

            // Avoid division by zero
            if (divisorPitch < 1e-4 || divisorYaw < 1e-4) {
                this.lastDeltaYaw = deltaYaw;
                this.lastDeltaPitch = deltaPitch;
                return;
            }

            final double ratioPitch = deltaPitch / divisorPitch;
            final double ratioYaw = deltaYaw / divisorYaw;

            // Sensitivity grid logic
            // A valid ratio usually stays well below 3,000.
            double threshold = 12000.0;

            if (ratioPitch > threshold || ratioYaw > threshold) {
                if (buffer.increase(player, 1.25) > 15.0) {
                    flag(data, String.format("Rotations do not match sensitivity grid. Ratios: Y:%.0f/P:%.0f", ratioYaw, ratioPitch));
                    buffer.reset(player, 5.0);
                }
            } else {
                buffer.decrease(player, 2.0); // Faster decay for valid mouse inputs
            }
        } else {
            buffer.decrease(player, 0.15);
        }

        this.lastDeltaYaw = deltaYaw;
        this.lastDeltaPitch = deltaPitch;
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\combat\aim\AimB.java
================================================================================


package ret.tawny.truthful.checks.impl.combat.aim;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'B', type = CheckType.AIM)
@SuppressWarnings("unused")
public final class AimB extends Check {

    private final CheckBuffer buffer = new CheckBuffer(5.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null)
            return;

        // Cinematic/Snap Check
        // Detects unnatural "snaps" (instant large rotation) followed by perfect
        // stillness or vice versa.

        float deltaYaw = Math.abs(data.getDeltaYaw());
        float lastDeltaYaw = Math.abs(data.getLastDeltaYaw());

        // Condition 1: Still -> Snap (Aimbot locking on)
        boolean snapStart = deltaYaw > 20.0 && lastDeltaYaw < 1.0;

        // Condition 2: Snap -> Still (Aimbot locking off or snapping to target then
        // stopping)
        boolean snapEnd = lastDeltaYaw > 20.0 && deltaYaw < 1.0;

        if (snapStart || snapEnd) {
            // We need to be careful about legitimate mouse flicks.
            // Usually legitimate flicks have *some* acceleration/deceleration frames, even
            // if small.
            // Instant 0 -> 20 -> 0 is very suspicious.

            if (buffer.increase(player, 1.0) > 5.0) {
                flag(data, String.format("Snap Rotation. Y: %.1f -> %.1f", lastDeltaYaw, deltaYaw));
                buffer.reset(player, 2.0);
            }
        } else {
            buffer.decrease(player, 0.5);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\combat\aim\AimC.java
================================================================================


package ret.tawny.truthful.checks.impl.combat.aim;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'C', type = CheckType.AIM)
@SuppressWarnings("unused")
public final class AimC extends Check {

    private final CheckBuffer buffer = new CheckBuffer(5.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null)
            return;

        float pitch = data.getPitch();

        // Logic: Invalid Pitch
        // Minecraft pitch is clamped between -90 (looking up) and 90 (looking down).
        // Some cheats allow > 90 (Headless) or < -90.
        if (Math.abs(pitch) > 90.0) {
            if (buffer.increase(player, 1.0) > 1.0) {
                flag(data, "Invalid Pitch: " + pitch);
                // Force reset pitch logic could go here if we could modify packets
            }
        } else {
            buffer.decrease(player, 0.1);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\combat\aim\AimD.java
================================================================================


package ret.tawny.truthful.checks.impl.combat.aim;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'D', type = CheckType.AIM)
@SuppressWarnings("unused")
public final class AimD extends Check {

    private final CheckBuffer buffer = new CheckBuffer(8.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper movePacketWrapper) {
        if (!movePacketWrapper.isRotationUpdate())
            return;
        final PlayerData playerData = Truthful.getInstance().getDataManager()
                .getPlayerData(movePacketWrapper.getPlayer());

        if (playerData == null)
            return;

        final float deltaYaw = Math.abs(playerData.getDeltaYaw());
        final float deltaPitch = Math.abs(playerData.getDeltaPitch());
        final float yawAccel = Math.abs(deltaYaw - Math.abs(playerData.getLastDeltaYaw()));
        final float pitchAccel = Math.abs(deltaPitch - Math.abs(playerData.getLastDeltaPitch()));
        final Player player = movePacketWrapper.getPlayer();

        // Check for "Perfect" acceleration (Smooth Aim)
        // If acceleration is extremely low (constant speed) while moving significantly.
        if (deltaYaw > 1.0F && deltaPitch > 1.0F && yawAccel < 1.0E-3F && pitchAccel < 1.0E-3F) {
            if (buffer.increase(player, 1.0) > 8.0) {
                flag(playerData, "Perfect rotation acceleration (Smooth Aim)");
                buffer.reset(player, 4.0);
            }
        } else {
            buffer.decrease(player, 1.5);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\combat\autoclicker\AutoClickerA.java
================================================================================


package ret.tawny.truthful.checks.impl.combat.autoclicker;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import org.bukkit.entity.Player;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.utils.math.MathHelper;

import java.util.ArrayList;
import java.util.List;

@CheckData(order = 'A', type = CheckType.AUTOCLICKER)
@SuppressWarnings("unused")
public final class AutoClickerA extends Check {

    private final CheckBuffer buffer = new CheckBuffer(10.0);
    private final List<Integer> delays = new ArrayList<>();
    private long lastClickTime;

    @Override
    public void handlePacketPlayerReceive(final PacketEvent event) {
        if (event.getPacketType() == PacketType.Play.Client.ARM_ANIMATION) {
            final Player player = event.getPlayer();
            final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

            if (data == null)
                return;
            if (data.isExempt())
                return;

            long now = System.currentTimeMillis();
            if (lastClickTime != 0) {
                int delay = (int) (now - lastClickTime);
                if (delay > 250) { // Reset if pause is too long
                    delays.clear();
                } else {
                    delays.add(delay);
                }
            }
            lastClickTime = now;

            if (delays.size() >= 20) {
                double kurtosis = MathHelper.getKurtosis(delays);
                double skewness = MathHelper.getSkewness(delays);

                // Logic: High Kurtosis means very peaked distribution (consistent clicks).
                // Human clicks are flatter (lower kurtosis).
                // Thresholds need tuning, but > 2.0 is often suspicious for simple
                // autoclickers.

                if (kurtosis > 1.5 && Math.abs(skewness) < 0.5) {
                    if (buffer.increase(player, 1.0) > 5.0) {
                        flag(data, String.format("Consistent Clicks. K: %.2f, S: %.2f", kurtosis, skewness));
                        buffer.reset(player, 2.0);
                    }
                } else {
                    buffer.decrease(player, 0.5);
                }
                delays.clear();
            }
        }
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\combat\autoclicker\AutoClickerB.java
================================================================================


package ret.tawny.truthful.checks.impl.combat.autoclicker;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import org.bukkit.entity.Player;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;

@CheckData(order = 'B', type = CheckType.AUTOCLICKER)
@SuppressWarnings("unused")
public final class AutoClickerB extends Check {

    private final CheckBuffer buffer = new CheckBuffer(5.0);
    private long lastClickTime;
    private int consistentTicks;
    private long lastDelay;

    @Override
    public void handlePacketPlayerReceive(final PacketEvent event) {
        if (event.getPacketType() == PacketType.Play.Client.ARM_ANIMATION) {
            final Player player = event.getPlayer();
            final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

            if (data == null)
                return;

            long now = System.currentTimeMillis();
            if (lastClickTime != 0) {
                long delay = now - lastClickTime;

                // Logic: 0 Variance / Perfect Consistency
                // If the delay is identical to the previous delay, we increment a counter.
                // Humans can hit the same ms delay occasionally, but not consistently.

                if (delay == lastDelay && delay < 250) {
                    if (++consistentTicks > 4) {
                        if (buffer.increase(player, 1.0) > 4.0) {
                            flag(data, "Perfect Click Consistency (Macro)");
                            buffer.reset(player, 2.0);
                        }
                    }
                } else {
                    consistentTicks = 0;
                    buffer.decrease(player, 0.25);
                }
                lastDelay = delay;
            }
            lastClickTime = now;
        }
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\combat\hitbox\HitboxB.java
================================================================================


package ret.tawny.truthful.checks.impl.combat.hitbox;

import org.bukkit.Location;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.util.Vector;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;

@CheckData(order = 'B', type = CheckType.HITBOX)
@SuppressWarnings("unused")
public final class HitboxB extends Check {

    private final CheckBuffer buffer = new CheckBuffer(5.0);

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
    public void onAttack(final EntityDamageByEntityEvent event) {
        if (!isEnabled()) return;
        if (!(event.getDamager() instanceof Player player)) return;

        if (Truthful.getInstance().isBedrockPlayer(player)) return;

        final PlayerData playerData = Truthful.getInstance().getDataManager().getPlayerData(player);
        if (playerData == null) return;

        final Entity target = event.getEntity();

        // 1. Calculate Vectors
        // Vector from Player Eye to Target Center
        Location origin = player.getEyeLocation();
        Location targetLoc = target.getLocation().add(0, target.getHeight() / 2.0, 0); // Aim at center of body

        Vector toTarget = targetLoc.toVector().subtract(origin.toVector());
        Vector lookDir = player.getLocation().getDirection();

        // 2. Angle Calculation
        // Dot product / (MagA * MagB) gives Cosine of angle.
        // We simply use Vector.angle() provided by Bukkit which returns radians.
        double angle = lookDir.angle(toTarget);
        double angleDegrees = Math.toDegrees(angle);

        // 3. Thresholds
        // Vanilla FOV is usually 70-90.
        // However, this is the angle from the CENTER cursor.
        // If target is at the edge of screen, angle is ~45 degrees.
        // A generous limit is 55 degrees (allowing for high FOV settings like Quake Pro).
        // If angle > 60, they are hitting something way off screen.

        double limit = 60.0;

        // Exemption: If target is extremely close (inside the player), angles get weird.
        if (origin.distance(targetLoc) < 0.8) {
            return;
        }

        if (angleDegrees > limit) {
            if (buffer.increase(player, 1.0) > 5.0) {
                flag(playerData, String.format("Hit outside FOV. Angle: %.1f, Limit: %.1f", angleDegrees, limit));
            }
        } else {
            buffer.decrease(player, 0.1);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\combat\hitbox\ReachA.java
================================================================================


package ret.tawny.truthful.checks.impl.combat.hitbox;

import org.bukkit.Location;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.compensation.CompensationTracker;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.utils.world.WorldUtils; // Ensure this import exists

@CheckData(order = 'A', type = CheckType.HITBOX)
@SuppressWarnings("unused")
public final class ReachA extends Check {

    private final CheckBuffer buffer = new CheckBuffer(5.0);

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
    public void onAttack(final EntityDamageByEntityEvent event) {
        if (!isEnabled()) return;
        if (!(event.getDamager() instanceof Player player)) return;

        if (Truthful.getInstance().isBedrockPlayer(player)) return;

        final PlayerData playerData = Truthful.getInstance().getDataManager().getPlayerData(player);
        if (playerData == null) return;

        final Entity target = event.getEntity();

        // --- FIX: LAG COMPENSATION ---
        Location targetLoc = target.getLocation();

        // Calculate Ping in Ticks
        int pingTicks = (int) Math.ceil(playerData.getPing() / 50.0);
        int currentTick = WorldUtils.getWorldTicks(player.getWorld()); // Use WorldUtils wrapper

        // Retrieve historical location
        CompensationTracker tracker = Truthful.getInstance().getCompensationTracker();
        if (tracker != null && tracker.getCompensationMap().containsKey(target)) {
            CompensationTracker.CompensatedEntity comp = tracker.getCompensationMap().get(target);
            Location historyLoc = comp.getLocationAt(currentTick, pingTicks);
            if (historyLoc != null) {
                targetLoc = historyLoc;
            }
        }

        // Calculate Distance to Compensated Location
        final double deltaX = playerData.getX() - targetLoc.getX();
        final double deltaZ = playerData.getZ() - targetLoc.getZ();
        final double horizontal = Math.sqrt(deltaX * deltaX + deltaZ * deltaZ);

        double maxReach = 3.05D;

        if (player.getGameMode().name().contains("CREATIVE")) maxReach = 4.5;

        // Sprinting reach expansion
        if (player.isSprinting()) maxReach += 0.2D;

        // Static buffer for latency jitter
        maxReach += 0.25;

        if (horizontal > maxReach) {
            if (buffer.increase(player, horizontal - maxReach) > 5.0) {
                flag(playerData, String.format("Reach %.2f > %.2f (Ping: %d)", horizontal, maxReach, playerData.getPing()));
                buffer.reset(player, 3.0);
                event.setCancelled(true); // Cancel hit if confirmed reach
            }
        } else {
            buffer.decrease(player, 0.5);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\combat\reach\ReachA.java
================================================================================


package ret.tawny.truthful.checks.impl.combat.reach;

import org.bukkit.GameMode;
import org.bukkit.Location;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.util.Vector;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.compensation.CompensationTracker;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.utils.world.WorldUtils;

@CheckData(order = 'A', type = CheckType.REACH)
@SuppressWarnings("unused")
public final class ReachA extends Check {

    private final CheckBuffer buffer = new CheckBuffer(10.0);

    @EventHandler
    public void onAttack(final EntityDamageByEntityEvent event) {
        if (!(event.getDamager() instanceof Player))
            return;

        final Player player = (Player) event.getDamager();
        final Entity target = event.getEntity();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null || player.getGameMode() == GameMode.CREATIVE)
            return;

        // --- LAG COMPENSATION ---
        Location targetLoc = target.getLocation();

        // Calculate Ping in Ticks (50ms = 1 tick)
        int pingTicks = (int) Math.ceil(data.getPing() / 50.0);
        int currentTick = WorldUtils.getWorldTicks(player.getWorld());

        // Retrieve historical location
        CompensationTracker tracker = Truthful.getInstance().getCompensationTracker();
        if (tracker != null && tracker.getCompensationMap().containsKey(target)) {
            CompensationTracker.CompensatedEntity comp = tracker.getCompensationMap().get(target);
            Location historyLoc = comp.getLocationAt(currentTick, pingTicks);
            if (historyLoc != null) {
                targetLoc = historyLoc;
            }
        }

        // --- 3D HITBOX MATH ---
        // Player eyes
        Location eyeLoc = player.getEyeLocation();

        // Target approximate hitbox center
        // Assume simplified hitbox width approx 0.4 (radius) and height 1.8
        // This calculates the closest point on the target's vertical axis to the player's eyes
        double targetY = targetLoc.getY();
        double playerY = eyeLoc.getY();

        // Clamp Y to the target's height bounds
        double clampedY = Math.max(targetY, Math.min(playerY, targetY + 1.9));

        Location closestTargetPoint = new Location(targetLoc.getWorld(), targetLoc.getX(), clampedY, targetLoc.getZ());

        // Calculate raw distance
        double distance = eyeLoc.distance(closestTargetPoint);

        // Subtract hitbox radius (approx 0.4 for players) + buffer
        double reach = distance - 0.4;

        double maxReach = 3.0; // Vanilla default

        // Dynamic adjustment
        if (data.getDeltaXZ() > 0.2) maxReach += 0.1; // Movement lag buffer
        if (player.isSprinting()) maxReach += 0.1; // Sprint buffer
        maxReach += (data.getPing() * 0.002); // Ping buffer (100ms = 0.2 blocks)

        // Hard cap
        double hardCap = 4.5;
        if (reach > maxReach && reach < 6.0) {
            // Only flag if it exceeds the calculated threshold
            if (reach > hardCap || buffer.increase(player, reach - maxReach) > 6.0) {
                flag(data, String.format("Reach (Compensated): %.2f > %.2f", reach, maxReach));
                buffer.reset(player, 3.0);
                event.setCancelled(true);
            }
        } else {
            buffer.decrease(player, 0.25);
        }
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\elytra\ElytraA.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.elytra;

import org.bukkit.GameMode;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.inventory.ItemStack;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'A', type = CheckType.ELYTRA)
@SuppressWarnings("unused")
public final class ElytraA extends Check {

    private final CheckBuffer buffer = new CheckBuffer(12.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null) return;

        // --- STRICT EXEMPTIONS ---
        if (!player.isGliding()) return;

        // 1. Must wear Elytra (Fixes "no wings" flags)
        ItemStack chest = player.getInventory().getChestplate();
        if (chest == null || chest.getType() != Material.ELYTRA) return;

        if (player.isInsideVehicle()) return;
        if (player.getGameMode() == GameMode.CREATIVE || player.getGameMode() == GameMode.SPECTATOR) return;
        try { if (player.isRiptiding()) return; } catch (Throwable ignored) {}

        if (data.isInLiquid() || data.isOnClimbable() || data.isInWeb()) return;
        if (data.getTicksTracked() - data.getLastFireworkTick() < 80) return;

        if (player.hasPotionEffect(org.bukkit.potion.PotionEffectType.LEVITATION)) return;

        double deltaY = data.getDeltaY();
        double deltaXZ = data.getDeltaXZ();
        double accel = deltaXZ - data.getLastDeltaXZ();

        // 1. Force Height (Rising)
        if (deltaY >= 0.1) {

            // --- FIX: SWOOP LOGIC ---
            // We allow rising if the player is losing speed (Converting Kinetic to Potential).
            // Previously required < -0.02. Relaxed to < 0.0 (Any deceleration).
            boolean isSwooping = accel < 0.0;

            if (!isSwooping && deltaXZ > 0.2 && data.getTicksInAir() > 20) {
                if (buffer.increase(player, 1.0) > 12.0) {
                    flag(data, String.format("Force Height. Y: %.4f, Speed: %.3f, Accel: %.4f", deltaY, deltaXZ, accel));
                    buffer.reset(player, 6.0);
                }
            } else {
                // Valid swoop, reduce buffer
                buffer.decrease(player, 0.5);
            }
            return;
        }

        // 2. Aerodynamic Drag (Relaxed)
        double absY = Math.abs(deltaY);
        double requiredDrop = (deltaXZ - 0.5) * 0.10;

        if (deltaXZ > 1.0 && deltaY < 0.0) {
            if (absY < requiredDrop) {
                if (buffer.increase(player, 1.0) > 12.0) {
                    flag(data, String.format("Invalid Glide Ratio (Drag). Speed: %.3f, Drop: %.4f, Req: %.4f", deltaXZ, absY, requiredDrop));
                    buffer.reset(player, 6.0);
                }
            } else {
                buffer.decrease(player, 0.25);
            }
        } else {
            buffer.decrease(player, 0.25);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\elytra\ElytraB.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.elytra;

import org.bukkit.GameMode;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'B', type = CheckType.ELYTRA)
@SuppressWarnings("unused")
public final class ElytraB extends Check {

    private final CheckBuffer buffer = new CheckBuffer(15.0); // Increased buffer

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null) return;

        // --- EXEMPTIONS ---
        if (!player.isGliding()) return;
        if (player.isInsideVehicle()) return;
        if (player.getGameMode() == GameMode.CREATIVE || player.getGameMode() == GameMode.SPECTATOR) return;
        try { if (player.isRiptiding()) return; } catch (Throwable ignored) {}
        if (data.isInLiquid() || data.isInWeb() || data.isOnClimbable()) return;
        if (data.getTicksTracked() - data.getLastFireworkTick() < 60) return;

        double deltaY = data.getDeltaY();
        double deltaXZ = data.getDeltaXZ();
        double acceleration = data.getDeltaXZ() - data.getLastDeltaXZ(); // Corrected: Check Horizontal Acceleration

        // Logic: Energy Generation
        // It is impossible to gain Speed (Accel > 0) AND gain Height (Rising) at the same time
        // without an external force (Firework).

        boolean rising = deltaY > 0.02; // Buffer for tiny floating point errors
        boolean gainingSpeed = acceleration > 0.01;
        boolean alreadyFast = deltaXZ > 0.4;

        if (rising && gainingSpeed && alreadyFast) {
            // Strict physics check
            if (buffer.increase(player, 1.0) > 15.0) {
                flag(data, String.format("Elytra Energy Generation. Rising: %.4f, Accel: %.4f", deltaY, acceleration));
                buffer.reset(player, 8.0);
            }
        } else {
            buffer.decrease(player, 0.5);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\elytra\ElytraC.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.elytra;

import org.bukkit.GameMode;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'C', type = CheckType.ELYTRA)
@SuppressWarnings("unused")
public final class ElytraC extends Check {

    private final CheckBuffer buffer = new CheckBuffer(10.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null) return;

        if (!player.isGliding()) return;
        if (player.isInsideVehicle()) return;
        if (player.getGameMode() == GameMode.CREATIVE || player.getGameMode() == GameMode.SPECTATOR) return;
        try { if (player.isRiptiding()) return; } catch (Throwable ignored) {}
        if (data.isInLiquid() || data.isInWeb() || data.isOnClimbable()) return;
        if (data.getTicksTracked() - data.getLastFireworkTick() < 60) return;

        double deltaXZ = data.getDeltaXZ();
        double deltaY = data.getDeltaY();

        // Only check if moving significantly forward and "floating" (deltaY is small)
        if (deltaXZ > 0.5 && deltaY < 0.1 && deltaY > -0.5) {

            if (Math.abs(deltaY) < 0.001) deltaY = 0.001; // Avoid div/0

            double ratio = deltaXZ / Math.abs(deltaY);

            // Vanilla Max Efficiency:
            // ~15-20. Cheats go 50+.
            // Limit 50 is very safe.
            double limit = 50.0;

            if (ratio > limit) {
                if (buffer.increase(player, 1.0) > 10.0) {
                    flag(data, String.format("Impossible Glide Ratio. Ratio: %.2f, Limit: %.2f", ratio, limit));
                    buffer.reset(player, 5.0);
                }
            } else {
                buffer.decrease(player, 0.25);
            }
        } else {
            buffer.decrease(player, 0.25);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\elytra\ElytraD.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.elytra;

import org.bukkit.GameMode;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.inventory.ItemStack;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'D', type = CheckType.ELYTRA)
@SuppressWarnings("unused")
public final class ElytraD extends Check {

    private final CheckBuffer buffer = new CheckBuffer(10.0);
    private double lastEnergy = 0.0;

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null) return;

        if (!player.isGliding()) {
            lastEnergy = 0.0;
            return;
        }

        // 1. Must wear Elytra
        ItemStack chest = player.getInventory().getChestplate();
        if (chest == null || chest.getType() != Material.ELYTRA) {
            lastEnergy = 0.0;
            return;
        }

        if (player.isInsideVehicle()) return;
        if (player.getGameMode() == GameMode.CREATIVE || player.getGameMode() == GameMode.SPECTATOR) return;
        try { if (player.isRiptiding()) return; } catch (Throwable ignored) {}

        if (data.getTicksTracked() - data.getLastFireworkTick() < 80) {
            lastEnergy = 0.0;
            return;
        }

        // --- FIX: HIGH ASCENT EXEMPTION ---
        // During a massive swoop (Y > 0.3 per tick), potential energy gains calculate
        // wildly differently between client and server due to sync.
        // We skip the check during the "Zoom" phase of the swoop.
        if (data.getDeltaY() > 0.3) {
            buffer.decrease(player, 0.5);
            updateEnergyState(player, data);
            return;
        }

        // Deceleration Exemption
        double acceleration = data.getDeltaXZ() - data.getLastDeltaXZ();
        if (acceleration < -0.01) {
            buffer.decrease(player, 0.25);
            updateEnergyState(player, data);
            return;
        }

        // --- ENERGY MATH ---
        double velSq = Math.pow(data.getDeltaX(), 2) + Math.pow(data.getDeltaY(), 2) + Math.pow(data.getDeltaZ(), 2);
        double heightEnergy = player.getLocation().getY() * 2.0;

        double currentEnergy = heightEnergy + velSq;

        if (lastEnergy > 0.0) {
            double diff = currentEnergy - lastEnergy;

            if (diff > 0.75) { // Increased threshold slightly
                if (data.getDeltaXZ() > 0.3) {
                    if (buffer.increase(player, 1.0) > 10.0) {
                        flag(data, String.format("Energy Gain. Diff: +%.4f", diff));
                        buffer.reset(player, 5.0);
                    }
                }
            } else {
                buffer.decrease(player, 0.25);
            }
        }

        this.lastEnergy = currentEnergy;
    }

    private void updateEnergyState(Player player, PlayerData data) {
        double velSq = Math.pow(data.getDeltaX(), 2) + Math.pow(data.getDeltaY(), 2) + Math.pow(data.getDeltaZ(), 2);
        this.lastEnergy = (player.getLocation().getY() * 2.0) + velSq;
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
        lastEnergy = 0.0;
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\elytra\ElytraE.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.elytra;

import org.bukkit.GameMode;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.util.Vector;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'E', type = CheckType.ELYTRA)
@SuppressWarnings("unused")
public final class ElytraE extends Check {

    private final CheckBuffer buffer = new CheckBuffer(10.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null) return;

        if (!player.isGliding()) return;
        if (player.isInsideVehicle()) return;
        if (player.getGameMode() == GameMode.CREATIVE || player.getGameMode() == GameMode.SPECTATOR) return;
        try { if (player.isRiptiding()) return; } catch (Throwable ignored) {}
        if (data.isInLiquid() || data.isInWeb() || data.isOnClimbable()) return;

        double speed = data.getDeltaXZ();

        // If slow, alignment is erratic. Only check at speed.
        if (speed > 0.6) {
            Vector move = new Vector(data.getDeltaX(), 0, data.getDeltaZ()).normalize();
            Vector look = player.getLocation().getDirection().setY(0).normalize();

            try {
                float angle = move.angle(look); // Radians
                double degrees = Math.toDegrees(angle);

                // Safe limit 60 degrees.
                // Vanilla Elytra allows slight sideways drift but not 90 degrees.
                if (degrees > 60.0) {
                    if (buffer.increase(player, 1.0) > 10.0) {
                        flag(data, String.format("Elytra Strafe / Misalignment. Angle: %.1f", degrees));
                        buffer.reset(player, 5.0);
                    }
                } else {
                    buffer.decrease(player, 0.25);
                }
            } catch (Exception ignored) {}
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\elytra\ElytraF.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.elytra;

import org.bukkit.GameMode;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'F', type = CheckType.ELYTRA)
@SuppressWarnings("unused")
public final class ElytraF extends Check {

    private final CheckBuffer buffer = new CheckBuffer(12.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null) return;

        if (!player.isGliding()) return;
        if (player.isInsideVehicle()) return;
        if (player.getGameMode() == GameMode.CREATIVE || player.getGameMode() == GameMode.SPECTATOR) return;
        try { if (player.isRiptiding()) return; } catch (Throwable ignored) {}
        if (data.isInLiquid() || data.isInWeb() || data.isOnClimbable()) return;
        if (data.getTicksTracked() - data.getLastFireworkTick() < 60) return;

        double speed = data.getDeltaXZ();
        float pitch = data.getPitch();

        double maxSpeed;

        // If looking UP (Negative pitch in Bukkit), you must slow down.
        // If looking DOWN (Positive pitch), you can speed up.

        if (pitch < -10.0) { // Looking up
            maxSpeed = 1.2; // Gravity slows you down
        } else if (pitch < 45.0) { // Level-ish
            maxSpeed = 2.0;
        } else { // Diving
            maxSpeed = 4.5; // Terminal velocity roughly
        }

        if (speed > maxSpeed) {
            // Allow momentum bleeding. If decelerating, it's fine.
            double acceleration = speed - data.getLastDeltaXZ();
            if (acceleration < -0.01) {
                buffer.decrease(player, 0.1);
                return;
            }

            if (buffer.increase(player, 1.0) > 12.0) {
                flag(data, String.format("Invalid Pitch/Speed. Speed: %.2f, Limit: %.2f, Pitch: %.1f", speed, maxSpeed, pitch));
                if (Truthful.getInstance().getConfiguration().isLagbacks()) {
                    player.teleport(data.getLastLocation());
                }
                buffer.reset(player, 6.0);
            }
        } else {
            buffer.decrease(player, 0.25);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\elytra\ElytraG.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.elytra;

import org.bukkit.GameMode;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.util.Vector;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'G', type = CheckType.ELYTRA)
@SuppressWarnings("unused")
public final class ElytraG extends Check {

    private final CheckBuffer buffer = new CheckBuffer(8.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null) return;

        if (player.getGameMode() == GameMode.CREATIVE || player.getGameMode() == GameMode.SPECTATOR) return;

        if (data.isInWeb() || (data.getTicksTracked() - data.getLastWebTick() < 20)) {
            buffer.decrease(player, 0.5);
            return;
        }

        Vector movement = new Vector(data.getDeltaX(), data.getDeltaY(), data.getDeltaZ());
        Vector direction = player.getLocation().getDirection();

        // Stalling threshold
        if (data.getDeltaXZ() < 0.3) {
            buffer.decrease(player, 0.1);
            return;
        }

        if (movement.lengthSquared() < 0.001 || direction.lengthSquared() < 0.001) {
            return;
        }

        float angle = (float) Math.toDegrees(movement.angle(direction));

        // Relaxed limit from 60.0 -> 75.0 to allow sharp vanilla turns
        if (angle > 75.0) {
            if (buffer.increase(player, 1.0) > 8.0) {
                flag(data, String.format("Elytra Misalignment. Angle: %.1f, Speed: %.2f", angle, data.getDeltaXZ()));

                if (Truthful.getInstance().getConfiguration().isLagbacks()) {
                    player.teleport(data.getLastLocation());
                }
                buffer.reset(player, 4.0);
            }
        } else {
            buffer.decrease(player, 0.5);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\elytra\ElytraI.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.elytra;

import org.bukkit.GameMode;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'I', type = CheckType.ELYTRA)
@SuppressWarnings("unused")
public final class ElytraI extends Check {

    private final CheckBuffer buffer = new CheckBuffer(10.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null) return;

        if (!player.isGliding()) return;
        if (player.isInsideVehicle()) return;
        if (player.getGameMode() == GameMode.CREATIVE || player.getGameMode() == GameMode.SPECTATOR) return;
        try { if (player.isRiptiding()) return; } catch (Throwable ignored) {}
        if (data.getTicksTracked() - data.getLastFireworkTick() < 60) return;

        if (data.isInWeb() || data.isInLiquid() || data.isNearVehicle()) {
            buffer.decrease(player, 0.5);
            return;
        }

        double deltaY = data.getDeltaY();
        double deltaXZ = data.getDeltaXZ();

        // Logic: Hover Check
        // If you are falling (deltaY < 0), you are fine unless it's EXTREMELY slow.
        // Lowered threshold to -0.005. If falling faster than that, it's gravity.
        if (deltaXZ < 0.1 && deltaY > -0.005) {
            if (buffer.increase(player, 1.0) > 10.0) {
                flag(data, String.format("Elytra Hover. Speed: %.3f, Drop: %.3f", deltaXZ, deltaY));
                // Manual teleport removed
                buffer.reset(player, 5.0);
            }
        } else {
            buffer.decrease(player, 0.25);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\elytra\ElytraK.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.elytra;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'K', type = CheckType.ELYTRA)
@SuppressWarnings("unused")
public final class ElytraK extends Check {

    private final CheckBuffer buffer = new CheckBuffer(8.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null)
            return;

        if (!player.isGliding() || player.isInsideVehicle())
            return;
        try {
            if (player.isRiptiding())
                return;
        } catch (Throwable ignored) {
        }

        if (data.getTicksTracked() - data.getLastFireworkTick() < 60)
            return;

        // --- FIX: WEB EXEMPTION ---
        if (data.isInWeb() || (data.getTicksTracked() - data.getLastWebTick() < 20)) {
            buffer.decrease(player, 0.5);
            return;
        }

        double deltaY = data.getDeltaY();
        double deltaXZ = data.getDeltaXZ();
        double lastDeltaXZ = data.getLastDeltaXZ();

        // Logic: Accelerating while Ascending
        // You cannot gain speed (Kinetic) while gaining height (Potential) without
        // external force (Fireworks).
        boolean ascending = deltaY > 0.0;
        boolean accelerating = deltaXZ > lastDeltaXZ + 0.01; // Significant acceleration

        if (ascending && accelerating) {
            if (buffer.increase(player, 1.0) > 8.0) {
                flag(data, String.format("Accelerating while Ascending. Y: %.4f, Accel: %.4f", deltaY,
                        deltaXZ - lastDeltaXZ));
                if (Truthful.getInstance().getConfiguration().isLagbacks()) {
                    player.teleport(data.getLastLocation());
                }
                buffer.reset(player, 4.0);
            }
        } else {
            buffer.decrease(player, 0.25);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\elytra\ElytraL.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.elytra;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'L', type = CheckType.ELYTRA)
@SuppressWarnings("unused")
public final class ElytraL extends Check {

    private final CheckBuffer buffer = new CheckBuffer(10.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null)
            return;

        if (!player.isGliding() || player.isInsideVehicle())
            return;
        try {
            if (player.isRiptiding())
                return;
        } catch (Throwable ignored) {
        }

        if (data.getTicksTracked() - data.getLastFireworkTick() < 60)
            return;

        // --- FIX: WEB EXEMPTION ---
        if (data.isInWeb() || (data.getTicksTracked() - data.getLastWebTick() < 20)) {
            buffer.decrease(player, 0.5);
            return;
        }

        double deltaY = data.getDeltaY();
        float pitch = data.getPitch();

        // Logic: Pitch Mismatch
        // If looking down (pitch > 10) but going up (deltaY > 0), that's impossible.
        if (pitch > 10.0 && deltaY > 0.1) {
            if (buffer.increase(player, 1.0) > 10.0) {
                flag(data, String.format("Pitch Mismatch. Pitch: %.1f, Y: %.4f", pitch, deltaY));
                if (Truthful.getInstance().getConfiguration().isLagbacks()) {
                    player.teleport(data.getLastLocation());
                }
                buffer.reset(player, 5.0);
            }
        } else {
            buffer.decrease(player, 0.25);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\elytra\ElytraM.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.elytra;

import org.bukkit.GameMode;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'M', type = CheckType.ELYTRA)
@SuppressWarnings("unused")
public final class ElytraM extends Check {

    private final CheckBuffer buffer = new CheckBuffer(15.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null) return;

        if (!player.isGliding()) return;
        if (player.isInsideVehicle()) return;
        if (player.getGameMode() == GameMode.CREATIVE || player.getGameMode() == GameMode.SPECTATOR) return;
        try { if (player.isRiptiding()) return; } catch (Throwable ignored) {}
        if (data.getTicksTracked() - data.getLastFireworkTick() < 60) return;

        if (data.isInWeb() || data.isInLiquid() || data.isNearVehicle()) {
            buffer.decrease(player, 0.5);
            return;
        }

        double deltaY = data.getDeltaY();
        double deltaXZ = data.getDeltaXZ();
        double lastDeltaXZ = data.getLastDeltaXZ();

        // Logic: Ascension Pattern
        if (deltaY > 0.0 && deltaY < 0.42) {
            // Momentum Trade: If slowing down, rising is allowed.
            if (deltaXZ < lastDeltaXZ) {
                buffer.decrease(player, 0.1);
                return;
            }

            if (buffer.increase(player, 1.0) > 15.0) {
                flag(data, String.format("Invalid Ascension Pattern. Y: %.4f", deltaY));
                // Manual teleport removed
                buffer.reset(player, 7.0);
            }
        } else {
            buffer.decrease(player, 0.1);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\fly\FlyA.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.fly;

import org.bukkit.GameMode;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.potion.PotionEffectType;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'A', type = CheckType.FLY)
public final class FlyA extends Check {

    private final CheckBuffer buffer = new CheckBuffer(12.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null) return;

        // --- EXEMPTIONS ---
        if (player.getGameMode() == GameMode.CREATIVE || player.getGameMode() == GameMode.SPECTATOR) return;
        if (player.getAllowFlight() || player.isFlying() || player.isInsideVehicle()) return;
        if (player.isGliding()) return;
        try { if (player.isRiptiding()) return; } catch (Throwable ignored) {}

        // Vehicle Exit Grace Period
        if (data.getTicksTracked() - data.getLastVehicleExitTick() < 40) {
            buffer.decrease(player, 0.5);
            return;
        }

        // Web Grace Period
        if (data.isInWeb() || (data.getTicksTracked() - data.getLastWebTick() < 20)) {
            buffer.decrease(player, 0.5);
            return;
        }

        if (player.hasPotionEffect(PotionEffectType.LEVITATION) ||
                player.hasPotionEffect(PotionEffectType.SLOW_FALLING) ||
                player.hasPotionEffect(PotionEffectType.JUMP_BOOST)) return;

        if (data.isInLiquid() || data.isOnClimbable() || data.isUnderBlock()) {
            buffer.decrease(player, 0.5);
            return;
        }

        if (!data.getVelocities().isEmpty() || data.isTeleportTick()) return;

        // Ghost block / connection lag exemption
        if (data.getTicksTracked() - data.getLastGhostBlockTick() < 10) {
            buffer.decrease(player, 1.0);
            return;
        }

        if (data.isOnGround() || data.isLastGround()) {
            buffer.decrease(player, 0.5);
            return;
        }

        double currentDeltaY = data.getDeltaY();
        double lastDeltaY = data.getLastDeltaY();

        // --- STEP EXEMPTION ---
        // Stepping up a slab (0.5), Snow (0.125 increments), or Block (1.0)
        // This usually happens when the server says ground=false for a tick during the step
        if (currentDeltaY > 0.0) {
            // Check common step heights with slight error margin
            if (Math.abs(currentDeltaY - 0.5) < 0.001 ||
                    Math.abs(currentDeltaY - 0.6) < 0.001 || // 1.0 step + jump boost sometimes
                    Math.abs(currentDeltaY - 1.0) < 0.001 ||
                    Math.abs(currentDeltaY - 0.42) < 0.001) { // Normal Jump
                buffer.decrease(player, 0.25);
                return;
            }
        }

        // Vanilla Gravity Prediction
        double predictedDeltaY = (lastDeltaY - 0.08D) * 0.9800000190734863D;

        // Threshold tolerance
        double difference = Math.abs(currentDeltaY - predictedDeltaY);

        // Only check if difference is significant and we aren't essentially stationary
        if (difference > 0.005 && Math.abs(currentDeltaY) > 0.005) {
            if (isInBubbleColumn(player)) return;

            if (buffer.increase(player, 1.0) > 12.0) {
                flag(data, String.format("Gravity Mismatch. Diff: %.5f, Y: %.4f", difference, currentDeltaY));
                // Manual teleport removed to prevent crash. flag() handles it.
            }
        } else {
            buffer.decrease(player, 0.25);
        }
    }

    private boolean isInBubbleColumn(Player player) {
        try {
            Block b = player.getLocation().getBlock();
            return b.getType().name().contains("BUBBLE_COLUMN");
        } catch (Exception e) {
            return false;
        }
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\fly\FlyB.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.fly;

import org.bukkit.GameMode;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.potion.PotionEffect;
import org.bukkit.potion.PotionEffectType;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'B', type = CheckType.FLY)
@SuppressWarnings("unused")
public final class FlyB extends Check {

    private final CheckBuffer buffer = new CheckBuffer(10.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null) return;

        if (player.getGameMode() == GameMode.CREATIVE || player.getGameMode() == GameMode.SPECTATOR) return;
        if (player.getAllowFlight() || player.isFlying() || player.isInsideVehicle()) return;
        if (player.isGliding()) return;

        try { if (player.isRiptiding()) return; } catch (Throwable ignored) {}

        if (data.isInLiquid() || data.isOnClimbable() || data.isInWeb()) {
            buffer.decrease(player, 0.5);
            return;
        }

        if (!data.getVelocities().isEmpty()) {
            buffer.decrease(player, 0.5);
            return;
        }

        // Slime block exemption
        if (data.isLastGround() && data.getLastGroundLocation().getBlock().getType().name().contains("SLIME")) {
            return;
        }

        // Check 1: Jump Height Limit
        if (data.isLastGround() && !data.isOnGround()) {
            double jumpLimit = 0.42f + (getPotionLevel(player, PotionEffectType.JUMP_BOOST) * 0.1);
            jumpLimit += 0.05; // Buffer

            if (data.getDeltaY() > jumpLimit) {
                // Ignore step ups
                boolean isStep = Math.abs(data.getDeltaY() - 0.5) < 0.001 || Math.abs(data.getDeltaY() - 0.6) < 0.001;

                if (!isStep) {
                    if (buffer.increase(player, 1.0) > 10.0) {
                        flag(data, String.format("Abnormal Jump Height. Y: %.4f, Max: %.4f", data.getDeltaY(), jumpLimit));
                    }
                }
            }
            return;
        }

        // Check 2: Mid-Air Ascension
        if (data.getTicksInAir() > 7 && data.getDeltaY() > 0.0) {
            if (player.hasPotionEffect(PotionEffectType.LEVITATION)) return;

            // Threshold > 0.01 prevents flags from tiny bobbing
            if (data.getDeltaY() > 0.01) {
                if (buffer.increase(player, 1.0) > 10.0) {
                    flag(data, "Ascension in mid-air (Jetpack/Fly)");
                }
            }
        } else {
            buffer.decrease(player, 0.25);
        }
    }

    private int getPotionLevel(Player player, PotionEffectType type) {
        for (PotionEffect effect : player.getActivePotionEffects()) {
            if (effect.getType().equals(type))
                return effect.getAmplifier() + 1;
        }
        return 0;
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\fly\FlyC.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.fly;

import org.bukkit.GameMode;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'C', type = CheckType.FLY)
@SuppressWarnings("unused")
public final class FlyC extends Check {

    private final CheckBuffer buffer = new CheckBuffer(10.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null) return;

        // 1. Gamemode & Flight
        if (player.getGameMode() == GameMode.CREATIVE || player.getGameMode() == GameMode.SPECTATOR) return;
        if (player.getAllowFlight() || player.isFlying()) return;
        if (player.isInsideVehicle() || player.isGliding()) return;
        try { if (player.isRiptiding()) return; } catch (Throwable ignored) {}

        // 2. Environmental
        if (data.isOnClimbable() || data.isInLiquid()) return;

        // Web Exemption
        if (data.isInWeb() || (data.getTicksTracked() - data.getLastWebTick() < 20)) {
            buffer.decrease(player, 0.5);
            return;
        }

        // 3. Boat/Entity Collision (CRITICAL FIX)
        // Bouncing on a boat or standing on it creates irregular gravity/hovering effects.
        if (data.isNearVehicle() || data.isNearEntity()) {
            buffer.decrease(player, 0.5);
            return;
        }

        // 4. Ground Check
        if (data.isOnGround()) return;

        double deltaY = data.getDeltaY();

        // 5. Hover Check
        // Logic: Moving very little vertically while in mid-air.
        if (Math.abs(deltaY) < 0.01) {

            // Ignore if under a block (Head Hitter jump)
            if (data.isUnderBlock()) {
                buffer.decrease(player, 0.25);
                return;
            }

            // Ignore if exactly 0.0 (Client often sends 0.0 during lag spikes or ghost ground)
            if (deltaY == 0.0) {
                buffer.decrease(player, 0.1);
                return;
            }

            if (buffer.increase(player, 1.0) > 10.0) {
                flag(data, String.format("Hovering/Gliding in air. Y: %.5f", deltaY));
                // Manual teleport handled by flag()
            }
        } else {
            buffer.decrease(player, 0.5);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\fly\FlyD.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.fly;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.potion.PotionEffectType;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'D', type = CheckType.FLY)
@SuppressWarnings("unused")
public final class FlyD extends Check {

    private final CheckBuffer buffer = new CheckBuffer(10.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null)
            return;

        if (player.getAllowFlight() || player.isInsideVehicle() || player.isGliding())
            return;
        try {
            if (player.isRiptiding())
                return;
        } catch (Throwable ignored) {
        }

        if (data.isInLiquid() || data.isOnClimbable() || data.isUnderBlock())
            return;
        if (player.hasPotionEffect(PotionEffectType.SLOW_FALLING)
                || player.hasPotionEffect(PotionEffectType.LEVITATION))
            return;

        // --- FIX: WEB EXEMPTION ---
        if (data.isInWeb() || (data.getTicksTracked() - data.getLastWebTick() < 20)) {
            buffer.decrease(player, 0.5);
            return;
        }

        double deltaY = data.getDeltaY();
        double lastDeltaY = data.getLastDeltaY();

        // Logic: Slow Falling
        // If falling (deltaY < 0) but falling slower than expected.
        // Expected drop increases over time.
        // If deltaY is consistently small (e.g. -0.1) while in air, it's suspicious.

        if (data.getTicksInAir() > 10 && deltaY < 0.0 && deltaY > -0.5) {
            double predictedDrop = (lastDeltaY - 0.08) * 0.98;

            // If we are falling significantly slower than predicted
            if (deltaY > predictedDrop + 0.1) {
                if (buffer.increase(player, 1.0) > 10.0) {
                    flag(data, String.format("Slow Falling. Y: %.4f, Pred: %.4f", deltaY, predictedDrop));
                    if (Truthful.getInstance().getConfiguration().isLagbacks()) {
                        player.teleport(data.getLastLocation());
                    }
                    buffer.reset(player, 5.0);
                }
            } else {
                buffer.decrease(player, 0.25);
            }
        } else {
            buffer.decrease(player, 0.25);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\fly\FlyE.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.fly;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'E', type = CheckType.FLY)
@SuppressWarnings("unused")
public final class FlyE extends Check {

    private final CheckBuffer buffer = new CheckBuffer(5.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null)
            return;

        if (player.getAllowFlight() || player.isInsideVehicle() || player.isGliding())
            return;
        try {
            if (player.isRiptiding())
                return;
        } catch (Throwable ignored) {
        }

        if (data.isInLiquid() || data.isOnClimbable())
            return;

        // --- FIX: WEB EXEMPTION ---
        if (data.isInWeb() || (data.getTicksTracked() - data.getLastWebTick() < 20)) {
            buffer.decrease(player, 0.5);
            return;
        }

        // Logic: Ground Spoof
        // Client claims to be on ground, but server says they are in air.
        // This is "NoFall" or "Ground Spoof".
        boolean clientGround = relMovePacketWrapper.isGround();
        boolean serverGround = data.isOnGround(); // Calculated by WorldUtils

        // Only check if strictly in air (server says NO ground nearby)
        if (clientGround && !serverGround) {
            // Check if they are actually near any block (slabs/stairs might be tricky)
            // WorldUtils.safeGround handles this, but let's be sure.
            // Also check for boat/entity collisions which might trick ground check.
            if (data.isNearVehicle() || data.isNearEntity())
                return;

            if (buffer.increase(player, 1.0) > 5.0) {
                flag(data, "Ground Spoof (NoFall)");
                if (Truthful.getInstance().getConfiguration().isLagbacks()) {
                    player.teleport(data.getLastLocation());
                }
                buffer.reset(player, 2.0);
            }
        } else {
            buffer.decrease(player, 0.5);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\noslow\NoSlowA.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.noslow;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'A', type = CheckType.NO_SLOW)
@SuppressWarnings("unused")
public final class NoSlowA extends Check {

    private final CheckBuffer buffer = new CheckBuffer(5.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper event) {
        final Player player = event.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null)
            return;

        // NoSlow Logic
        // If player is using an item (blocking/eating/bow), they should be slowed down.
        // Max speed while using item is significantly lower (approx 0.2 * 0.2 = 0.04?
        // No, it's a multiplier).
        // Usually it's -80% speed? Or set to 0.2?
        // Walking speed is 0.22. Blocking is much slower.

        if (player.isBlocking() || player.isHandRaised()) { // isHandRaised covers eating/drinking in newer versions?
            double deltaX = data.getDeltaX();
            double deltaZ = data.getDeltaZ();
            double speed = Math.hypot(deltaX, deltaZ);

            // Threshold for blocking speed.
            // 0.2 (Base) * 0.2 (Multiplier) is very slow.
            // But sprinting + blocking might be different.
            // Let's set a safe threshold.

            double maxSpeed = 0.2; // Safe upper bound for blocking/eating

            if (speed > maxSpeed && data.isOnGround()) {
                if (buffer.increase(player, 1.0) > 5.0) {
                    flag(data, String.format("NoSlow: %.3f > %.3f", speed, maxSpeed));
                    buffer.reset(player, 2.0);
                }
            } else {
                buffer.decrease(player, 0.25);
            }
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\speed\SpeedA.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.speed;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.potion.PotionEffect;
import org.bukkit.potion.PotionEffectType;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.utils.world.WorldUtils;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'A', type = CheckType.SPEED)
public final class SpeedA extends Check {

    private final CheckBuffer buffer = new CheckBuffer(10.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        if (!relMovePacketWrapper.isPositionUpdate()) return;

        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null) return;

        // Exemptions
        if (player.getAllowFlight() || player.isFlying() || player.isGliding() || player.isInsideVehicle()) return;
        if (data.isTeleportTick()) return;

        if (data.getTicksTracked() - data.getLastVehicleExitTick() < 40) {
            buffer.decrease(player, 0.5);
            return;
        }

        // Web Exemption
        if (data.isInWeb() || (data.getTicksTracked() - data.getLastWebTick() < 20)) {
            buffer.decrease(player, 0.5);
            return;
        }

        if (data.getMaxVelocity() > 0) {
            buffer.decrease(player, 1.0);
            return;
        }

        try { if (player.isRiptiding()) return; } catch (Throwable ignored) {}

        if (data.getTicksTracked() - data.getLastGlideTick() < 20) {
            buffer.decrease(player, 0.5);
            return;
        }

        double limit = 0.0;
        double attributeSpeed = getBaseSpeed(player);

        if (data.isOnGround()) {
            float friction = WorldUtils.getSlippinessMultiplier(player);
            limit = attributeSpeed;

            // Ice/Slime adjustment
            if (friction > 0.65) {
                limit *= 2.3;
            } else {
                limit += 0.1;
            }
        } else {
            // Air Speed Limit
            limit = 0.36 + (getPotionLevel(player, PotionEffectType.SPEED) * 0.05);

            // Jump Boost increases air speed slightly due to momentum
            if (player.hasPotionEffect(PotionEffectType.JUMP_BOOST)) {
                limit += 0.05;
            }

            if (WorldUtils.hasLowFrictionBelow(player)) {
                limit = 0.65 + (getPotionLevel(player, PotionEffectType.SPEED) * 0.05);
            }
        }

        limit += 0.04; // Buffer

        double speed = data.getDeltaXZ();

        if (speed > limit) {
            if (buffer.increase(player, 1.0) > 10.0) {
                flag(data, String.format("Speed Limit Exceeded. Speed: %.3f, Max: %.3f", speed, limit));
                // Manual teleport removed to prevent Async Crash
            }
        } else {
            buffer.decrease(player, 0.5);
        }
    }

    private double getBaseSpeed(Player player) {
        double base = 0.285;
        if (player.hasPotionEffect(PotionEffectType.SPEED)) {
            base *= 1.0 + 0.2 * getPotionLevel(player, PotionEffectType.SPEED);
        }
        if (player.hasPotionEffect(PotionEffectType.SLOWNESS)) {
            base = base * (1.0 - 0.15 * getPotionLevel(player, PotionEffectType.SLOWNESS));
        }
        return base;
    }

    private int getPotionLevel(Player player, PotionEffectType type) {
        for (PotionEffect effect : player.getActivePotionEffects()) {
            if (effect.getType().equals(type)) return effect.getAmplifier() + 1;
        }
        return 0;
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\speed\SpeedB.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.speed;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.utils.player.PredictionUtils;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'B', type = CheckType.SPEED)
@SuppressWarnings("unused")
public final class SpeedB extends Check {

    private final CheckBuffer buffer = new CheckBuffer(15.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        if (!relMovePacketWrapper.isPositionUpdate()) return;

        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null) return;
        if (player.getAllowFlight() || player.isFlying() || player.isGliding() || player.isInsideVehicle()) return;
        if (data.isTeleportTick() || !data.getVelocities().isEmpty()) return;
        if (data.isInLiquid() || data.wasInLiquid()) return;

        if (data.getTicksTracked() - data.getLastVehicleExitTick() < 40) {
            buffer.decrease(player, 0.5);
            return;
        }

        double deltaXZ = data.getDeltaXZ();
        double lastDeltaXZ = data.getLastDeltaXZ();

        float friction = 0.91F;
        if (data.isLastGround()) {
            friction *= PredictionUtils.getBlockFriction(player.getWorld(), data.getLastLocation());
        }

        double acceleration;
        if (data.isLastGround()) {
            acceleration = PredictionUtils.getBaseSpeed(player) * (0.16277136 / (friction * friction * friction));

            // Jump boost momentum allowance
            if (data.getDeltaY() > 0.0) acceleration += 0.2;
        } else {
            acceleration = 0.026;
            if (player.hasPotionEffect(org.bukkit.potion.PotionEffectType.SPEED)) acceleration += 0.005;
        }

        double predicted = (lastDeltaXZ * friction) + acceleration;
        double bufferLimit = predicted + 0.05;

        if (deltaXZ > bufferLimit) {
            if (deltaXZ > 0.2) {
                double diff = deltaXZ - predicted;
                if (buffer.increase(player, 1.0) > 15.0) {
                    flag(data, String.format("Friction. Diff: %.4f, Speed: %.3f", diff, deltaXZ));
                    // Manual teleport removed to prevent Async Crash
                    buffer.reset(player, 10.0);
                }
            }
        } else {
            buffer.decrease(player, 0.25);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\speed\SpeedC.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.speed;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.util.Vector;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.utils.world.WorldUtils;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'C', type = CheckType.SPEED)
@SuppressWarnings("unused")
public final class SpeedC extends Check {

    private final CheckBuffer buffer = new CheckBuffer(12.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        if (!relMovePacketWrapper.isPositionUpdate()) return;

        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null) return;

        if (player.getAllowFlight() || player.isFlying() || player.isGliding() || player.isInsideVehicle()) return;

        if (data.isTeleportTick() || !data.getVelocities().isEmpty()) return;
        try { if (player.isRiptiding()) return; } catch (Throwable ignored) {}
        if (WorldUtils.hasLowFrictionBelow(player)) return;

        if (data.getDeltaXZ() < 0.22) return;

        Vector move = new Vector(data.getDeltaX(), 0, data.getDeltaZ());

        Vector look = player.getLocation().getDirection();
        look.setY(0).normalize();

        float angle = move.angle(look);
        double degrees = Math.toDegrees(angle);

        if (player.isSprinting()) {
            if (degrees > 60.0) {
                if (buffer.increase(player, 1.0) > 12.0) {
                    flag(data, String.format("Omni-Sprint. Angle: %.1f", degrees));
                    // Manual teleport removed
                }
            } else {
                buffer.decrease(player, 0.15);
            }
        }

        if (!data.isOnGround() && !data.isLastGround()) {
            if (data.getDeltaXZ() > 0.3 && degrees > 40.0) {
                if (buffer.increase(player, 1.0) > 15.0) {
                    flag(data, String.format("Impossible Air Strafe. Speed: %.3f, Angle: %.1f", data.getDeltaXZ(), degrees));
                }
            }
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\spoof\GroundSpoofA.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.spoof;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.utils.world.WorldUtils;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'A', type = CheckType.SPOOF)
@SuppressWarnings("unused")
public final class GroundSpoofA extends Check {

    private final CheckBuffer buffer = new CheckBuffer(5.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        if (!relMovePacketWrapper.isPositionUpdate()) return;

        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData playerData = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (playerData == null) return;

        // --- EXEMPTIONS ---
        // 1. Vehicle Exit (Desync window)
        if (playerData.getTicksTracked() - playerData.getLastVehicleExitTick() < 40) {
            buffer.decrease(player, 0.5);
            return;
        }

        // 2. Standard Exemption
        if (player.getAllowFlight() || player.isFlying() || player.isGliding() || player.isInsideVehicle()) return;
        if (playerData.isTeleportTick() || playerData.isInLiquid() || WorldUtils.hasClimbableNearby(player)) return;

        // 3. Boat/Entity Standing (CRITICAL FIX)
        // If near a boat/minecart or another entity (stacking), the server ground check will fail.
        // We must trust the client here or perform complex entity collision boxes (expensive).
        if (playerData.isNearVehicle() || playerData.isNearEntity()) {
            buffer.decrease(player, 0.5);
            return;
        }

        final boolean clientGround = relMovePacketWrapper.isGround();
        final boolean serverGround = playerData.isOnGround();

        // Logic: Check if client claims ground but server says air
        // We require a few ticks of air to prevent slab/stair edge cases
        if (clientGround && !serverGround && playerData.getTicksInAir() > 4) {
            if (buffer.increase(player, 1.0) > 5.0) {
                flag(playerData, "Client claims onGround without server-side support");
                buffer.reset(player, 2.5);
            }
        } else {
            buffer.decrease(player, 0.5);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\strafe\StrafeA.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.strafe;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.utils.world.WorldUtils;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'A', type = CheckType.STRAFE)
@SuppressWarnings("unused")
public final class StrafeA extends Check {

    private final CheckBuffer buffer = new CheckBuffer(8.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper event) {
        final Player player = event.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null) return;

        // Exemption: Flying/Creative/Spectator
        if (player.isFlying() || data.isExempt()) return;

        // Exemption: Under Block (Head Hitter)
        if (data.isUnderBlock()) {
            buffer.decrease(player, 0.25);
            return;
        }

        // 1. Ice/Slime Exemption (Low friction allows high speed)
        if (WorldUtils.hasLowFrictionBelow(player)) return;

        // 2. Landing/Momentum Exemption (CRITICAL FIX)
        // When landing, you carry air speed (~0.35 - 0.6) for a few ticks.
        // We only want to check SUSTAINED ground speed here.
        // Let SpeedB handle the complex momentum math.
        if (data.getTicksOnGround() < 7) {
            buffer.decrease(player, 0.1);
            return;
        }

        // 3. Stair/Slab Exemption
        // Walking down stairs increases horizontal speed momentarily.
        // If we are moving vertically while on "ground", we are likely on stairs/slopes.
        if (Math.abs(data.getDeltaY()) > 0.001) {
            return;
        }

        double deltaX = data.getDeltaX();
        double deltaZ = data.getDeltaZ();
        double speed = Math.hypot(deltaX, deltaZ);

        // Calculate base speed with attributes
        double maxSpeed = getBaseSpeed(player);

        // Buffer for turning/strafing variants
        // 0.03 covers 45-degree strafe optimization
        maxSpeed += 0.03;

        // Logic: Ground Speed Limit
        if (speed > maxSpeed && data.isOnGround()) {

            // Check if velocity is active (velocity would explain high speed)
            if (data.getVelocities().isEmpty()) {
                if (buffer.increase(player, 1.0) > 8.0) {
                    flag(data, String.format("Invalid Strafe Speed: %.3f > %.3f", speed, maxSpeed));
                    buffer.reset(player, 4.0);
                }
            }
        } else {
            buffer.decrease(player, 0.1);
        }
    }

    private double getBaseSpeed(Player player) {
        // Vanilla Base Speeds: ~0.22 (Walk), ~0.281 (Sprint)
        double base = 0.29;
        if (player.isSprinting())
            base = 0.295;

        if (player.hasPotionEffect(org.bukkit.potion.PotionEffectType.SPEED)) {
            int amplifier = getPotionLevel(player, org.bukkit.potion.PotionEffectType.SPEED);
            base *= 1.0 + 0.2 * amplifier;
        }
        if (player.hasPotionEffect(org.bukkit.potion.PotionEffectType.SLOWNESS)) {
            int amplifier = getPotionLevel(player, org.bukkit.potion.PotionEffectType.SLOWNESS);
            base = base * (1.0 - 0.15 * amplifier);
        }
        return base;
    }

    private int getPotionLevel(Player player, org.bukkit.potion.PotionEffectType type) {
        for (org.bukkit.potion.PotionEffect effect : player.getActivePotionEffects()) {
            if (effect.getType().equals(type))
                return effect.getAmplifier() + 1;
        }
        return 0;
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\movement\timer\TimerA.java
================================================================================


package ret.tawny.truthful.checks.impl.movement.timer;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@CheckData(order = 'A', type = CheckType.TIMER)
@SuppressWarnings("unused")
public final class TimerA extends Check {

    private final Map<UUID, Long> lastPacketTime = new ConcurrentHashMap<>();
    private final Map<UUID, Double> balanceMap = new ConcurrentHashMap<>();

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null)
            return;

        if (data.getTicksTracked() < 100 || data.isTeleportTick()) {
            lastPacketTime.put(player.getUniqueId(), System.nanoTime());
            return;
        }

        long now = System.nanoTime();
        // Initialize with current time to prevent huge initial spikes
        long last = lastPacketTime.getOrDefault(player.getUniqueId(), now);

        long diffNano = now - last;
        double diffMs = diffNano / 1_000_000.0;

        double balance = balanceMap.getOrDefault(player.getUniqueId(), -50.0);

        balance += 50.0; // Add 50ms per tick (expected)
        balance -= diffMs; // Subtract actual time taken

        // FIX: More generous lag spike forgiveness
        // If the server froze or client lagged hard, balance drops massively.
        // Cap it at -500ms (10 ticks buffer)
        if (balance < -500.0) {
            balance = -500.0;
        }

        // FIX: Increased threshold from 75.0 to 100.0 (2 ticks)
        // This reduces false flags from minor network jitter
        if (balance > 100.0) {
            if (data.getTicksTracked() > 150) {
                flag(data, String.format("Game speed too fast. Balance: +%.2fms", balance));
                // Reset balance to 0 to prevent spam, but don't punish further immediately
                balance = 0.0;
            }
        }

        balanceMap.put(player.getUniqueId(), balance);
        lastPacketTime.put(player.getUniqueId(), now);
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        lastPacketTime.remove(event.getPlayer().getUniqueId());
        balanceMap.remove(event.getPlayer().getUniqueId());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\raycast\RaycastA.java
================================================================================


package ret.tawny.truthful.checks.impl.raycast;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import org.bukkit.GameMode;
import org.bukkit.Location;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.entity.Player;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.utils.world.BlockUtils;
import ret.tawny.truthful.utils.world.WorldUtils;
import ret.tawny.truthful.wrapper.impl.client.action.PlayerBlockPlacePacketWrapper;

@CheckData(order = 'A', type = CheckType.RAYCAST)
@SuppressWarnings("unused") // Suppress "never used" warning, as this class is instantiated by reflection.
public final class RaycastA extends Check {

    public RaycastA() {
        Truthful.getInstance().getScheduler().registerDispatcher(this::handlePlacement, PacketType.Play.Client.BLOCK_PLACE);
        Truthful.getInstance().getScheduler().registerDispatcher(this::handlePlacement, PacketType.Play.Client.USE_ITEM);
    }

    private void handlePlacement(final PacketEvent packetEvent) {
        if (!isEnabled()) return;

        final Player player = packetEvent.getPlayer();
        if (player.getGameMode() == GameMode.CREATIVE) return;

        final PlayerData playerData = Truthful.getInstance().getDataManager().getPlayerData(player);
        if (playerData == null) return;

        final PlayerBlockPlacePacketWrapper blockPlacePacketWrapper = new PlayerBlockPlacePacketWrapper(packetEvent);
        final BlockFace face = blockPlacePacketWrapper.getBlockFace();

        if (face == null) return;

        final Block anchor = blockPlacePacketWrapper.getBlock();
        final Block placedAgainst = BlockUtils.getRelativeBlock(anchor, face);

        final Location eye = player.getEyeLocation();
        final Location target = placedAgainst.getLocation().add(0.5D, 0.5D, 0.5D);

        final double reach = eye.distance(target);

        double maxReach = 4.5D;
        if (player.isSprinting()) maxReach += 0.2D;
        maxReach += Math.min(0.7D, playerData.getPing() * 0.0025D);

        if (WorldUtils.hasClimbableNearby(player) || WorldUtils.isLiquid(player)) {
            maxReach += 0.4D;
        }

        if (reach > maxReach && !player.isInsideVehicle() && !player.isGliding()) {
            flag(playerData, String.format("Reach %.2f > %.2f", reach, maxReach));
        }
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\world\fastbreak\FastBreakA.java
================================================================================


package ret.tawny.truthful.checks.impl.world.fastbreak;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import com.comphenix.protocol.wrappers.EnumWrappers;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.potion.PotionEffect;
import org.bukkit.potion.PotionEffectType;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@CheckData(order = 'A', type = CheckType.FAST_BREAK)
@SuppressWarnings("unused")
public final class FastBreakA extends Check {

    private final CheckBuffer buffer = new CheckBuffer(10.0);
    private final Map<UUID, Long> startTimes = new HashMap<>();

    @Override
    public void handlePacketPlayerReceive(final PacketEvent event) {
        if (event.getPacketType() == PacketType.Play.Client.BLOCK_DIG) {
            final Player player = event.getPlayer();
            final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

            if (data == null || player.getGameMode().name().contains("CREATIVE"))
                return;

            EnumWrappers.PlayerDigType type = event.getPacket().getPlayerDigTypes().read(0);

            if (type == EnumWrappers.PlayerDigType.START_DESTROY_BLOCK) {
                startTimes.put(player.getUniqueId(), System.currentTimeMillis());
            } else if (type == EnumWrappers.PlayerDigType.STOP_DESTROY_BLOCK) {
                Long startTime = startTimes.remove(player.getUniqueId());
                if (startTime != null) {
                    long duration = System.currentTimeMillis() - startTime;

                    // Calculate expected time
                    // This is a simplified calculation.
                    // We need block hardness.
                    // Note: In a real anti-cheat, we'd need precise tool/enchantment calculations.

                    // Placeholder logic:
                    if (duration < 50) { // Impossible to break anything in < 50ms (1 tick) unless instant break
                        // Check for instant break conditions (high efficiency + weak block)
                        // If not instant break, flag.

                        if (buffer.increase(player, 1.0) > 5.0) {
                            flag(data, "FastBreak (Instant): " + duration + "ms");
                            buffer.reset(player, 2.0);
                        }
                    }
                }
            } else if (type == EnumWrappers.PlayerDigType.ABORT_DESTROY_BLOCK) {
                startTimes.remove(player.getUniqueId());
            }
        }
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\world\fastbreak\GhostHandA.java
================================================================================


package ret.tawny.truthful.checks.impl.world.fastbreak;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import com.comphenix.protocol.wrappers.BlockPosition;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.util.Vector;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;

import java.util.Set;

@CheckData(order = 'A', type = CheckType.RAYCAST) // Using RAYCAST type for GhostHand
@SuppressWarnings("unused")
public final class GhostHandA extends Check {

    private final CheckBuffer buffer = new CheckBuffer(5.0);

    @Override
    public void handlePacketPlayerReceive(final PacketEvent event) {
        if (event.getPacketType() == PacketType.Play.Client.BLOCK_DIG) {
            final Player player = event.getPlayer();
            final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

            if (data == null)
                return;

            BlockPosition pos = event.getPacket().getBlockPositionModifier().read(0);
            Location targetLoc = pos.toLocation(player.getWorld());

            // Raytrace Check
            // Check if there are solid blocks between eyes and target.

            Location eyeLoc = player.getEyeLocation();
            Vector direction = targetLoc.toVector().subtract(eyeLoc.toVector()).normalize();
            double distance = eyeLoc.distance(targetLoc);

            // Simple Raytrace
            // We step through the line and check for collisions.
            // Note: Bukkit's rayTraceBlocks is better if available.

            // Simplified logic:
            // If distance > 1.0 and we hit something else first...

            // For now, we'll just check distance as a sanity check (Reach for blocks)
            if (distance > 6.0) {
                if (buffer.increase(player, 1.0) > 5.0) {
                    flag(data, "Block Reach: " + distance);
                    buffer.reset(player, 2.0);
                }
            }
        }
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\world\jesus\JesusA.java
================================================================================


package ret.tawny.truthful.checks.impl.world.jesus;

import org.bukkit.block.Block;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.inventory.ItemStack;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.utils.world.WorldUtils;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'A', type = CheckType.JESUS)
@SuppressWarnings("unused")
public final class JesusA extends Check {

    private final CheckBuffer buffer = new CheckBuffer(15.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        if (!relMovePacketWrapper.isPositionUpdate())
            return;

        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null)
            return;

        if (player.getAllowFlight() || player.isFlying() || player.isInsideVehicle())
            return;
        if (data.isTeleportTick())
            return;

        if (data.getTicksTracked() - data.getLastVehicleExitTick() < 40) {
            buffer.decrease(player, 0.5);
            return;
        }

        if (player.isSwimming())
            return;

        if (data.getTicksTracked() - data.getLastGhostBlockTick() < 10) {
            buffer.decrease(player, 1.0);
            return;
        }

        // Logic: Only check if currently in liquid
        if (!data.isInLiquid()) {
            buffer.decrease(player, 0.5);
            return;
        }

        // Logic: Exiting Liquid exemption
        // If we were in liquid last tick, but are now moving onto a solid block (ground),
        // we might have high speed from a jump.
        if (data.wasInLiquid() && WorldUtils.safeGround(player)) {
            buffer.decrease(player, 0.5);
            return;
        }

        if (isInBubbleColumn(player))
            return;

        // Lily pad check / Nearby solid check
        if (WorldUtils.nearBlock(player)) {
            buffer.decrease(player, 0.25);
            return;
        }

        final double deltaY = data.getDeltaY();
        final double deltaXZ = data.getDeltaXZ();

        // 1. Solid Liquid Check (Walking on water)
        boolean solidLiquid = (Math.abs(deltaY) < 0.005) && deltaXZ > 0.05;

        // 2. Speed Check
        double speedLimit = 0.15 + (getDepthStriderLevel(player) * 0.05);

        if (deltaY > 0)
            speedLimit += 0.1;

        boolean tooFast = deltaXZ > speedLimit && !data.isLastGround();

        if (solidLiquid) {
            if (buffer.increase(player, 1.0) > 15.0) {
                flag(data, String.format("Walking flat on water. dY: %.4f", deltaY));
                buffer.reset(player, 5.0);
            }
        } else if (tooFast) {
            if (buffer.increase(player, 1.0) > 15.0) {
                flag(data, String.format("Moving too fast in water. Hz: %.3f, Limit: %.3f", deltaXZ, speedLimit));
                buffer.reset(player, 5.0);
            }
        } else {
            buffer.decrease(player, 0.25);
        }
    }

    private boolean isInBubbleColumn(Player player) {
        try {
            Block b = player.getLocation().getBlock();
            return b.getType().name().contains("BUBBLE_COLUMN");
        } catch (Exception e) {
            return false;
        }
    }

    private int getDepthStriderLevel(Player player) {
        ItemStack boots = player.getInventory().getBoots();
        if (boots == null)
            return 0;
        return boots.getEnchantmentLevel(Enchantment.DEPTH_STRIDER);
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\world\scaffold\ScaffoldA.java
================================================================================


package ret.tawny.truthful.checks.impl.world.scaffold;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import org.bukkit.Location;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.entity.Player;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.action.PlayerBlockPlacePacketWrapper;

@CheckData(order = 'A', type = CheckType.SCAFFOLD)
@SuppressWarnings("unused")
public final class ScaffoldA extends Check {

    @Override
    public void handlePacketPlayerReceive(final PacketEvent event) {
        if (!event.getPacketType().equals(PacketType.Play.Client.BLOCK_PLACE)) return;

        final Player player = event.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);
        if (data == null) return;

        final PlayerBlockPlacePacketWrapper wrapper = new PlayerBlockPlacePacketWrapper(event);
        final BlockFace face = wrapper.getBlockFace();
        final Block block = wrapper.getBlock();

        if (face == null || face == BlockFace.SELF) return;

        // --- GEOMETRY CHECK ---
        // Instead of raytracing, we check relative position.
        // If placing on the SOUTH face (Z+), the player should generally be on the South side (Z > BlockZ).

        Location eyeLoc = player.getEyeLocation();
        double dx = eyeLoc.getX() - (block.getX() + 0.5);
        double dy = eyeLoc.getY() - (block.getY() + 0.5);
        double dz = eyeLoc.getZ() - (block.getZ() + 0.5);

        // Tolerance: 0.5 (block extent) + 0.2 (reach around buffer)
        // If we are excessively on the "wrong side" of the block for the face we clicked, flag.
        boolean impossible = false;

        switch (face) {
            case NORTH: // Face is at Z - 0.5. We should be Z < 0.5 approx.
                // If we are at Z > 0.8 (Far South), we can't see North face.
                if (dz > 0.8) impossible = true;
                break;
            case SOUTH: // Face is at Z + 0.5.
                if (dz < -0.8) impossible = true;
                break;
            case WEST: // Face is at X - 0.5
                if (dx > 0.8) impossible = true;
                break;
            case EAST: // Face is at X + 0.5
                if (dx < -0.8) impossible = true;
                break;
            case UP: // Face is at Y + 0.5. We must be above Y - 0.5 roughly.
                if (dy < -0.8) impossible = true;
                break;
            case DOWN: // Face is at Y - 0.5. We must be below Y + 0.5 roughly.
                if (dy > 0.8) impossible = true;
                break;
        }

        if (impossible) {
            // Final check: Raytrace (ScaffoldI) handles precise aim.
            // This check is just for GROSS violations (e.g. placing on the back of a block through the block).
            flag(data, "Placed on impossible block face relative to position. Face: " + face);
        }
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\world\scaffold\ScaffoldB.java
================================================================================


package ret.tawny.truthful.checks.impl.world.scaffold;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import org.bukkit.entity.Player;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.utils.world.BlockUtils;
import ret.tawny.truthful.wrapper.impl.client.action.PlayerBlockPlacePacketWrapper;

@CheckData(order = 'B', type = CheckType.SCAFFOLD)
@SuppressWarnings("unused")
public final class ScaffoldB extends Check {

    // Tolerance for floating point errors
    private static final double EPSILON = 1.0E-4;

    @Override
    public void handlePacketPlayerReceive(final PacketEvent event) {
        if(!event.getPacketType().equals(PacketType.Play.Client.BLOCK_PLACE)) return;

        final Player player = event.getPlayer();
        final PlayerData playerData = Truthful.getInstance().getDataManager().getPlayerData(player);
        if(playerData == null) return;

        final PlayerBlockPlacePacketWrapper wrapper = new PlayerBlockPlacePacketWrapper(event);

        if (BlockUtils.isAbnormal(wrapper.getBlock().getType())) return;

        if (!this.validate(wrapper)) {
            flag(playerData, "Invalid block hit vector. " + wrapper.getHitVec());
        }
    }

    private boolean validate(final PlayerBlockPlacePacketWrapper wrapper) {
        final double facingX = wrapper.getHitVec().getX();
        final double facingY = wrapper.getHitVec().getY();
        final double facingZ = wrapper.getHitVec().getZ();

        // Check bounds with epsilon
        if (facingX < -EPSILON || facingX > 1.0 + EPSILON ||
                facingY < -EPSILON || facingY > 1.0 + EPSILON ||
                facingZ < -EPSILON || facingZ > 1.0 + EPSILON) {
            return false;
        }

        if (wrapper.getBlockFace() == null) return true;

        // Check face alignment
        // If we click the NORTH face, Z must be 0 (or close to it).
        return switch (wrapper.getBlockFace()) {
            case NORTH -> Math.abs(facingZ) < EPSILON;
            case SOUTH -> Math.abs(facingZ - 1.0) < EPSILON;
            case WEST -> Math.abs(facingX) < EPSILON;
            case EAST -> Math.abs(facingX - 1.0) < EPSILON;
            case DOWN -> Math.abs(facingY) < EPSILON;
            case UP -> Math.abs(facingY - 1.0) < EPSILON;
            default -> true;
        };
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\world\scaffold\ScaffoldC.java
================================================================================


package ret.tawny.truthful.checks.impl.world.scaffold;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import org.bukkit.block.BlockFace;
import org.bukkit.entity.Player;
import org.bukkit.util.Vector;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.action.PlayerBlockPlacePacketWrapper;

@CheckData(order = 'C', type = CheckType.SCAFFOLD)
@SuppressWarnings("unused")
public final class ScaffoldC extends Check {

    private final CheckBuffer buffer = new CheckBuffer(5.0);

    @Override
    public void handlePacketPlayerReceive(final PacketEvent event) {
        if (!event.getPacketType().equals(PacketType.Play.Client.BLOCK_PLACE)) return;

        final Player player = event.getPlayer();
        // Only check if sprinting (this check is for Sprint-Scaffold)
        if (!player.isSprinting() && !player.isGliding()) return;

        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);
        if (data == null || data.isTeleportTick()) return;

        final PlayerBlockPlacePacketWrapper wrapper = new PlayerBlockPlacePacketWrapper(event);
        final BlockFace face = wrapper.getBlockFace();

        if (face == null || face == BlockFace.UP || face == BlockFace.DOWN || face == BlockFace.SELF) {
            return;
        }

        // Get Face Normal (Direction the face is pointing)
        Vector normal = new Vector(face.getModX(), face.getModY(), face.getModZ());

        // Get Player Horizontal Velocity
        Vector velocity = new Vector(data.getDeltaX(), 0, data.getDeltaZ());

        // Check dot product
        // If I place on EAST face (Normal 1,0,0), I must be looking/moving WEST.
        // Velocity (-1, 0, 0). Normal (1, 0, 0). Dot = -1. (OK).
        // Scaffold: Sprint East (+1). Place East (+1). Dot = +1. (BAD).

        double dot = velocity.dot(normal);

        // Threshold: 0.0 allows perfectly perpendicular movement.
        // > 0.1 means actively moving in the direction of the face (impossible).
        if (dot > 0.15) {
            if (buffer.increase(player, 1.0) > 5.0) {
                flag(data, String.format("Impossible sprinting direction. Dot: %.3f, Face: %s", dot, face));
            }
        } else {
            buffer.decrease(player, 0.25);
        }
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\world\scaffold\ScaffoldD.java
================================================================================


package ret.tawny.truthful.checks.impl.world.scaffold;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import org.bukkit.block.BlockFace;
import org.bukkit.entity.Player;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.action.PlayerBlockPlacePacketWrapper;

@CheckData(order = 'D', type = CheckType.SCAFFOLD)
@SuppressWarnings("unused")
public final class ScaffoldD extends Check {

    private final CheckBuffer buffer = new CheckBuffer(5.0);

    @Override
    public void handlePacketPlayerReceive(final PacketEvent event) {
        if (!event.getPacketType().equals(PacketType.Play.Client.BLOCK_PLACE))
            return;

        final Player player = event.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);
        if (data == null || data.isTeleportTick())
            return;

        // Only check if moving fast enough (Sprinting or fast walking)
        if (!player.isSprinting() && data.getDeltaXZ() < 0.22)
            return;

        final PlayerBlockPlacePacketWrapper wrapper = new PlayerBlockPlacePacketWrapper(event);
        float pitch = data.getPitch();

        // --- FIX: Vertical Placement Check ---
        // Scaffold is specifically about bridging *under* you.
        // If the block being placed is at or above the player's feet Y,
        // they are likely building a wall or placing in front.
        double playerY = player.getLocation().getY();
        double blockY = wrapper.getBlock().getY();

        if (blockY >= playerY) {
            buffer.decrease(player, 0.5);
            return;
        }

        // Range of "Looking Forward"
        boolean lookingForward = pitch < 60.0F && pitch > -60.0F;

        if (lookingForward && player.isSprinting()) {
            // If sprinting forward, looking forward, but placing below us (bridging),
            // that's usually impossible without looking down.

            if (wrapper.getBlockFace() != BlockFace.UP && wrapper.getBlockFace() != BlockFace.DOWN) {
                if (buffer.increase(player, 1.0) > 5.0) {
                    flag(data, String.format("Sprint Bridging without looking down. Pitch: %.1f", pitch));
                    // Manual teleport removed to prevent crash
                }
            }
        } else {
            buffer.decrease(player, 0.5);
        }
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\world\scaffold\ScaffoldE.java
================================================================================


package ret.tawny.truthful.checks.impl.world.scaffold;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;

@CheckData(order = 'E', type = CheckType.SCAFFOLD)
@SuppressWarnings("unused")
public final class ScaffoldE extends Check {

    @Override
    public void handlePacketPlayerReceive(final PacketEvent event) {
        PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(event.getPlayer());
        if (data == null) return;

        // Track when the player switches their item slot
        if (event.getPacketType() == PacketType.Play.Client.HELD_ITEM_SLOT) {
            data.setLastSlotSwitchTime(System.currentTimeMillis());
        }

        // When they place a block, check how long it has been since they switched
        if (event.getPacketType() == PacketType.Play.Client.BLOCK_PLACE) {
            long timeSinceSwitch = System.currentTimeMillis() - data.getLastSlotSwitchTime();

            // A human cannot switch items and place a block in under ~50ms consistently.
            // We check for an impossibly low time.
            if (timeSinceSwitch < 5) {
                flag(data, "Impossibly fast item switch and place. Time: " + timeSinceSwitch + "ms");
            }
        }
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\world\scaffold\ScaffoldF.java
================================================================================


package ret.tawny.truthful.checks.impl.world.scaffold;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

@CheckData(order = 'F', type = CheckType.SCAFFOLD)
@SuppressWarnings("unused")
public final class ScaffoldF extends Check {

    private final CheckBuffer buffer = new CheckBuffer(20.0);

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        Player player = relMovePacketWrapper.getPlayer();
        PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);
        if (data == null) return;

        long timeSincePlace = System.currentTimeMillis() - data.getLastBlockPlaceTime();

        // Only analyze pitch stability within a short window after a block is placed.
        if (timeSincePlace > 300) {
            buffer.decrease(player, 0.5); // Forgive buffer when not actively scaffolding.
            return;
        }

        float deltaPitch = Math.abs(data.getDeltaPitch());
        float deltaYaw = Math.abs(data.getDeltaYaw());

        // --- FINAL REWORKED LOGIC ---
        // A static pitch is only suspicious if the player is also turning. A human cannot
        // move their mouse horizontally without some minor vertical jitter. A cheat can.
        // This stops the check from flagging players bridging in a straight line.
        boolean suspicious = deltaPitch < 0.001f      // Pitch is perfectly static
                && deltaYaw > 0.1f                     // AND Yaw is changing
                && data.getPitch() > 70                // AND they are looking down (bridging)
                && data.getDeltaXZ() > 0.1;            // AND they are moving

        if (suspicious) {
            if (buffer.increase(player, 1.0) > 20.0) {
                String debug = String.format("Unnatural pitch stability while turning. dP: %.4f, dY: %.4f", deltaPitch, deltaYaw);
                flag(data, debug);
            }
        } else {
            buffer.decrease(player, 0.75);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\world\scaffold\ScaffoldG.java
================================================================================


package ret.tawny.truthful.checks.impl.world.scaffold;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.utils.math.MathHelper;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@CheckData(order = 'G', type = CheckType.SCAFFOLD)
@SuppressWarnings("unused")
public final class ScaffoldG extends Check {

    private final Map<UUID, PlayerScaffoldData> scaffoldDataMap = new ConcurrentHashMap<>();

    @Override
    public void handleRelMove(final RelMovePacketWrapper relMovePacketWrapper) {
        if (!relMovePacketWrapper.isRotationUpdate()) return;

        final Player player = relMovePacketWrapper.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (data == null || data.isTeleportTick()) return;

        // Only check if looking down (Bridging)
        // Pitch 90 is straight down. Pitch 0 is forward.
        if (data.getPitch() < 60.0) return;

        // Only check significant snaps. Tiny movements are often too noisy.
        if (Math.abs(data.getDeltaYaw()) < 5.0) return;

        PlayerScaffoldData scaffoldData = scaffoldDataMap.computeIfAbsent(player.getUniqueId(), id -> new PlayerScaffoldData());

        float deltaYaw = Math.abs(data.getDeltaYaw());
        float lastDeltaYaw = Math.abs(data.getLastDeltaYaw());

        long gcdYaw = MathHelper.gcd((long) (deltaYaw * 16777216.0), (long) (lastDeltaYaw * 16777216.0));

        // --- FIX: Sensitivity / Smoothing Compatibility ---
        // Values like 64, 128, 256, etc. appear when players use mouse smoothing or specific gaming mice.
        // These values are mathematically "off-grid" but consistent with hardware smoothing.
        // Valid 'Bot' rotations often return 1 or very close to 0 relative to the multiplier.
        // We lowered the threshold to 40 to filter out these smoothed inputs.
        if (gcdYaw < 40) {
            scaffoldData.violations++;
            // Require a streak of failures to confirm robotic movement
            if (scaffoldData.violations > 10) {
                flag(data, String.format("Rotation GCD failure. YawGCD: %d", gcdYaw));
                scaffoldData.violations = 0;
            }
        } else {
            // Instant forgiveness for valid input
            scaffoldData.violations = 0;
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        scaffoldDataMap.remove(event.getPlayer().getUniqueId());
    }

    private static class PlayerScaffoldData {
        private int violations = 0;
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\world\scaffold\ScaffoldH.java
================================================================================


package ret.tawny.truthful.checks.impl.world.scaffold;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.player.PlayerQuitEvent;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;

@CheckData(order = 'H', type = CheckType.SCAFFOLD)
@SuppressWarnings("unused")
public final class ScaffoldH extends Check {

    private final CheckBuffer buffer = new CheckBuffer(5.0);

    @Override
    public void handlePacketPlayerReceive(final PacketEvent event) {
        if (!event.getPacketType().equals(PacketType.Play.Client.BLOCK_PLACE)) return;

        final Player player = event.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);
        if (data == null || data.getDeltaXZ() < 0.1) return; // Only check when moving

        int ticksSinceLastPlace = data.getTicksTracked() - data.getLastBlockPlaceTick();

        // Calculate the minimum number of ticks required to travel one block distance
        double requiredTicks = 1.0 / data.getDeltaXZ();

        // If the player places a block faster than they could have possibly moved to the next position...
        if (ticksSinceLastPlace < requiredTicks && ticksSinceLastPlace > 0) {
            if (buffer.increase(player, 1.0) > 5.0) {
                flag(data, String.format("Impossible placement cadence. TSLP: %d, RT: %.2f", ticksSinceLastPlace, requiredTicks));
            }
        } else {
            buffer.decrease(player, 0.1);
        }
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        buffer.remove(event.getPlayer());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\world\scaffold\ScaffoldI.java
================================================================================


package ret.tawny.truthful.checks.impl.world.scaffold;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import org.bukkit.Location;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.entity.Player;
import org.bukkit.util.Vector;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.utils.world.BlockUtils;
import ret.tawny.truthful.wrapper.impl.client.action.PlayerBlockPlacePacketWrapper;

@CheckData(order = 'I', type = CheckType.SCAFFOLD)
@SuppressWarnings("unused")
public final class ScaffoldI extends Check {

    private final CheckBuffer buffer = new CheckBuffer(4.0);

    // Tolerance relaxed to 0.05 to account for network desync/rotation smoothing
    private static final double TOLERANCE = 0.05;

    @Override
    public void handlePacketPlayerReceive(final PacketEvent event) {
        if (!event.getPacketType().equals(PacketType.Play.Client.BLOCK_PLACE)) return;

        final Player player = event.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);
        if (data == null || data.isTeleportTick()) return;

        final PlayerBlockPlacePacketWrapper wrapper = new PlayerBlockPlacePacketWrapper(event);
        final BlockFace face = wrapper.getBlockFace();

        if (face == null || face == BlockFace.SELF) return;
        if (BlockUtils.isAbnormal(wrapper.getBlock().getType())) return;

        Location eyePos = player.getEyeLocation();
        Block targetBlock = wrapper.getBlock();

        // Check 1: Trace with Current Rotation
        boolean hitCurrent = rayTraceFace(eyePos, eyePos.getDirection(), targetBlock, face);

        // Check 2: Trace with Last Rotation (Lag compensation)
        Vector lastDir = getVectorForRotation(data.getLastPitch(), data.getLastYaw());
        boolean hitLast = rayTraceFace(eyePos, lastDir, targetBlock, face);

        if (!hitCurrent && !hitLast) {
            if (buffer.increase(player, 1.5) > 4.0) {
                flag(data, String.format("Raytrace Mismatch (Strict). Face: %s, P: %.1f",
                        face.name(), data.getPitch()));

                if (Truthful.getInstance().getConfiguration().isLagbacks()) {
                    player.teleport(data.getLastLocation());
                }
            }
        } else {
            buffer.decrease(player, 0.25);
        }
    }

    private boolean rayTraceFace(Location origin, Vector direction, Block block, BlockFace face) {
        double blockX = block.getX();
        double blockY = block.getY();
        double blockZ = block.getZ();

        double planeX = blockX;
        double planeY = blockY;
        double planeZ = blockZ;
        Vector normal;

        switch (face) {
            case UP:    planeY += 1.0; normal = new Vector(0, 1, 0); break;
            case DOWN:  normal = new Vector(0, -1, 0); break;
            case EAST:  planeX += 1.0; normal = new Vector(1, 0, 0); break;
            case WEST:  normal = new Vector(-1, 0, 0); break;
            case SOUTH: planeZ += 1.0; normal = new Vector(0, 0, 1); break;
            case NORTH: normal = new Vector(0, 0, -1); break;
            default: return true;
        }

        double denom = normal.dot(direction);
        if (Math.abs(denom) < 1.0E-6) return false;

        Vector planePoint = new Vector(planeX, planeY, planeZ);
        Vector diff = planePoint.subtract(origin.toVector());

        double t = diff.dot(normal) / denom;
        if (t < 0) return false; // Behind player
        if (t > 6.0) return false; // Too far

        Vector intersect = origin.toVector().add(direction.clone().multiply(t));

        return isInside(intersect, blockX, blockY, blockZ, face);
    }

    private boolean isInside(Vector point, double bx, double by, double bz, BlockFace face) {
        double x = point.getX();
        double y = point.getY();
        double z = point.getZ();

        double minX = bx - TOLERANCE; double maxX = bx + 1 + TOLERANCE;
        double minY = by - TOLERANCE; double maxY = by + 1 + TOLERANCE;
        double minZ = bz - TOLERANCE; double maxZ = bz + 1 + TOLERANCE;

        switch (face) {
            case UP:
            case DOWN:
                return x >= minX && x <= maxX && z >= minZ && z <= maxZ;
            case NORTH:
            case SOUTH:
                return x >= minX && x <= maxX && y >= minY && y <= maxY;
            case WEST:
            case EAST:
                return y >= minY && y <= maxY && z >= minZ && z <= maxZ;
            default:
                return true;
        }
    }

    private Vector getVectorForRotation(float pitch, float yaw) {
        double yawRad = Math.toRadians(yaw);
        double pitchRad = Math.toRadians(pitch);
        double x = -Math.sin(yawRad) * Math.cos(pitchRad);
        double y = -Math.sin(pitchRad);
        double z = Math.cos(yawRad) * Math.cos(pitchRad);
        return new Vector(x, y, z);
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\impl\world\scaffold\ScaffoldJ.java
================================================================================


package ret.tawny.truthful.checks.impl.world.scaffold;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.CheckBuffer;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.checks.api.data.CheckType;
import ret.tawny.truthful.data.PlayerData;

@CheckData(order = 'J', type = CheckType.SCAFFOLD)
@SuppressWarnings("unused")
public final class ScaffoldJ extends Check {

    private final CheckBuffer buffer = new CheckBuffer(6.0);
    private float lastPlacePitch = 0f;
    private int lastPlaceTick = 0;

    @Override
    public void handlePacketPlayerReceive(final PacketEvent event) {
        // In 1.8 Protocol, BLOCK_PLACE is sent for interactions (Air Click) too.
        if (!event.getPacketType().equals(PacketType.Play.Client.BLOCK_PLACE)) return;

        final Player player = event.getPlayer();
        final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);
        if (data == null) return;

        // --- FIX 1: Must be holding a block ---
        // If holding a sword or air, you are interacting, not scaffolding.
        // getItemInHand() is deprecated but maintains cross-version compatibility best here.
        try {
            @SuppressWarnings("deprecation")
            ItemStack hand = player.getItemInHand();
            if (hand == null || !hand.getType().isBlock()) {
                return;
            }
        } catch (Exception e) {
            return;
        }

        // --- FIX 2: Must be moving ---
        // If standing still, static pitch is normal (you aren't moving your mouse).
        if (data.getDeltaXZ() < 0.1 && Math.abs(data.getDeltaY()) < 0.1) {
            buffer.decrease(player, 0.1);
            return;
        }

        // --- FIX 3: Ignore same-tick packets (Burst Clicks) ---
        // If you click 15 CPS, you send multiple packets per tick.
        // Pitch doesn't change between packets in the same tick.
        if (data.getTicksTracked() == lastPlaceTick) {
            return;
        }

        float pitch = data.getPitch();
        float yaw = data.getYaw();

        // Check 1: Static Pitch (Rotation Lock)
        // If pitch is IDENTICAL to last place packet, it's robotic.
        // Ignore 0.0 and 90.0 (common snapping points).
        if (Math.abs(pitch - lastPlacePitch) == 0.0 && pitch != 0.0 && pitch != 90.0 && Math.abs(pitch) < 89.9) {
            if (buffer.increase(player, 1.0) > 6.0) {
                flag(data, "Rotation Lock (Static Pitch). P: " + pitch);
                // Manual teleport removed
            }
        } else {
            buffer.decrease(player, 0.25);
        }

        // Check 2: Axis Snapping (Yaw)
        // Cheats often snap to 45, 90, 135, 180 degrees.
        if (yaw % 45.0 == 0.0 && data.getDeltaXZ() > 0.1) {
            if (buffer.increase(player, 1.0) > 6.0) {
                flag(data, "Rotation Lock (Axis Snap). Y: " + yaw);
            }
        }

        this.lastPlacePitch = pitch;
        this.lastPlaceTick = data.getTicksTracked();
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\checks\registry\CheckRegistry.java
================================================================================


package ret.tawny.truthful.checks.registry;

import org.bukkit.Bukkit;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.api.Check;
import ret.tawny.truthful.checks.api.data.CheckData;
import ret.tawny.truthful.utils.reflection.Manager;

public final class CheckRegistry extends Manager<Class<? extends Check>, Check> {

    public CheckRegistry() {
        this.register(Truthful.getInstance().getPlugin(), Check.class, "ret.tawny.truthful.checks.impl", CheckData.class);
    }

    public void init() {
        // Register Bukkit events for all loaded checks.
        this.getCollection().forEach(check -> {
            if (check.isEnabled()) {
                Bukkit.getPluginManager().registerEvents(check, Truthful.getInstance().getPlugin());
            }
        });

        // Use the plugin's logger, as recommended by Paper.
        long enabledChecks = this.getCollection().stream().filter(Check::isEnabled).count();
        Truthful.getInstance().getPlugin().getLogger().info("Successfully loaded and registered " + enabledChecks + " checks.");
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\commands\api\ICommand.java
================================================================================


package ret.tawny.truthful.commands.api;

import org.bukkit.command.Command;
import org.bukkit.command.CommandSender;

public interface ICommand {
    public boolean onCommand(final CommandSender sender, final Command command, final String head, final String[] args);
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\commands\impl\CommandCancel.java
================================================================================


package ret.tawny.truthful.commands.impl;

import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;

public final class CommandCancel implements CommandExecutor {
    @Override
    public boolean onCommand(CommandSender sender, Command command, String head, String[] args) {
        return false;
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\commands\impl\CommandManager.java
================================================================================


package ret.tawny.truthful.commands.impl;

import org.bukkit.Bukkit;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.database.LogManager;
import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;

public class CommandManager implements CommandExecutor {

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!sender.hasPermission("truthful.admin")) {
            sender.sendMessage("¬ßcNo permission.");
            return true;
        }

        if (args.length == 0) {
            sendHelp(sender);
            return true;
        }

        switch (args[0].toLowerCase()) {
            case "menu":
            case "gui":
                if (sender instanceof Player) {
                    Truthful.getInstance().getGuiManager().openMainMenu((Player) sender);
                } else {
                    sender.sendMessage("¬ßcPlayers only.");
                }
                break;

            case "exempt":
                if (args.length < 2) {
                    sender.sendMessage("¬ßcUsage: /truthful exempt <player>");
                    return true;
                }
                Player target = Bukkit.getPlayer(args[1]);
                if (target == null) {
                    sender.sendMessage("¬ßcPlayer not found.");
                    return true;
                }
                PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(target);
                if (data != null) {
                    boolean newState = !data.isExempt();
                    data.setExempt(newState);
                    sender.sendMessage(newState ? "¬ßaPlayer is now exempt." : "¬ßcPlayer is no longer exempt.");
                }
                break;

            // --- NEW: ATTRIBUTE/INFO COMMAND ---
            case "info":
            case "attributes":
            case "attr":
                if (args.length < 2) {
                    sender.sendMessage("¬ßcUsage: /truthful info <player>");
                    return true;
                }
                handleInfo(sender, args[1]);
                break;

            case "logs":
            case "history":
                if (args.length < 2) {
                    sender.sendMessage("¬ßcUsage: /truthful logs <player>");
                    return true;
                }
                handleLogs(sender, args[1]);
                break;

            case "export":
                sender.sendMessage("¬ß7Exporting database to CSV...");
                Bukkit.getScheduler().runTaskAsynchronously(Truthful.getInstance().getPlugin(), () -> {
                    File file = Truthful.getInstance().getLogManager().exportToCsv();
                    if (file != null) {
                        sender.sendMessage("¬ßaExport successful!");
                        sender.sendMessage("¬ß7File: ¬ßf" + file.getAbsolutePath());
                    } else {
                        sender.sendMessage("¬ßcExport failed. Check console.");
                    }
                });
                break;

            default:
                sendHelp(sender);
                break;
        }
        return true;
    }

    private void handleInfo(CommandSender sender, String targetName) {
        Player target = Bukkit.getPlayer(targetName);
        if (target == null) {
            sender.sendMessage("¬ßcPlayer not found.");
            return;
        }
        PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(target);
        if (data == null) {
            sender.sendMessage("¬ßcNo data found for player.");
            return;
        }

        boolean isBedrock = Truthful.getInstance().isBedrockPlayer(target);

        sender.sendMessage("¬ß8¬ßm--------------------------------");
        sender.sendMessage("¬ßc¬ßlPlayer Attributes: ¬ßf" + target.getName());
        sender.sendMessage("");
        sender.sendMessage(" ¬ß8¬ª ¬ß7Brand: ¬ßc" + (data.getClientBrand() == null ? "Unknown" : data.getClientBrand()));
        sender.sendMessage(" ¬ß8¬ª ¬ß7Platform: ¬ßf" + (isBedrock ? "Bedrock" : "Java"));
        sender.sendMessage(" ¬ß8¬ª ¬ß7Ping: ¬ßf" + data.getPing() + "ms");
        sender.sendMessage(" ¬ß8¬ª ¬ß7Violations: ¬ßf" + data.getVl());
        sender.sendMessage("");
        sender.sendMessage(" ¬ß8¬ª ¬ß7Physics State:");
        sender.sendMessage("    ¬ß7Ground: " + (data.isOnGround() ? "¬ßaTrue" : "¬ßcFalse"));
        sender.sendMessage("    ¬ß7Liquid: " + (data.isInLiquid() ? "¬ßaTrue" : "¬ßcFalse"));
        sender.sendMessage("    ¬ß7Climbable: " + (data.isOnClimbable() ? "¬ßaTrue" : "¬ßcFalse"));
        sender.sendMessage("    ¬ß7Near Vehicle: " + (data.isNearVehicle() ? "¬ßaTrue" : "¬ßcFalse"));
        sender.sendMessage("    ¬ß7Webs: " + (data.isInWeb() ? "¬ßaTrue" : "¬ßcFalse"));
        sender.sendMessage("¬ß8¬ßm--------------------------------");
    }

    private void handleLogs(CommandSender sender, String targetName) {
        sender.sendMessage("¬ß7Fetching logs for ¬ßc" + targetName + "¬ß7...");
        Bukkit.getScheduler().runTaskAsynchronously(Truthful.getInstance().getPlugin(), () -> {
            List<LogManager.LogEntry> logs = Truthful.getInstance().getLogManager().getLogs(targetName, 10);
            if (logs.isEmpty()) {
                sender.sendMessage("¬ßcNo logs found.");
                return;
            }
            SimpleDateFormat sdf = new SimpleDateFormat("MM-dd HH:mm");
            sender.sendMessage("¬ß8¬ßm---------------------------");
            for (LogManager.LogEntry log : logs) {
                sender.sendMessage(String.format("¬ß8[¬ß7%s¬ß8] ¬ßc%s ¬ß8(¬ßfVL:%d¬ß8) ¬ß7%s",
                        sdf.format(new Date(log.timestamp)),
                        log.check,
                        log.vl,
                        log.data
                ));
            }
            sender.sendMessage("¬ß8¬ßm---------------------------");
        });
    }

    private void sendHelp(CommandSender sender) {
        sender.sendMessage("¬ßc¬ßlTruthful Anti-Cheat");
        sender.sendMessage("¬ß7/truthful info <player> ¬ß8- ¬ßfView Client Brand & Attributes");
        sender.sendMessage("¬ß7/truthful menu ¬ß8- ¬ßfOpen GUI");
        sender.sendMessage("¬ß7/truthful exempt <player> ¬ß8- ¬ßfToggle check exemption");
        sender.sendMessage("¬ß7/truthful logs <player> ¬ß8- ¬ßfView recent violations");
        sender.sendMessage("¬ß7/truthful export ¬ß8- ¬ßfSave all logs to CSV file");
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\compensation\CompensationTracker.java
================================================================================


package ret.tawny.truthful.compensation;

import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Player;
import ret.tawny.truthful.utils.tick.ITickable;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

public final class CompensationTracker implements ITickable {

    // Map of Entity -> History
    private final HashMap<Entity, CompensatedEntity> compensationMap;

    public CompensationTracker() {
        this.compensationMap = new HashMap<>();
    }

    public HashMap<Entity, CompensatedEntity> getCompensationMap() {
        return compensationMap;
    }

    @Override
    public void tick() {
        // Clean up logged out players
        compensationMap.keySet().removeIf(entity -> !entity.isValid() || (entity instanceof Player && !((Player) entity).isOnline()));

        final int maxHistorySize = 20; // Store last 1 second (20 ticks)
        final int currentTick = Bukkit.getCurrentTick();

        // Track all online players
        for (Player player : Bukkit.getOnlinePlayers()) {
            CompensatedEntity data = compensationMap.computeIfAbsent(player, k -> new CompensatedEntity());
            data.tick(maxHistorySize, currentTick, player.getLocation());
        }
    }

    /**
     * Tracked Entity History
     */
    public static final class CompensatedEntity {
        // Maps ServerTick -> Location
        private final LinkedHashMap<Integer, Location> history;

        public CompensatedEntity() {
            this.history = new LinkedHashMap<>();
        }

        public void tick(final int cap, final int tick, final Location location) {
            this.cull(cap);
            this.history.put(tick, location);
        }

        /**
         * Get the location of this entity at a specific server tick in the past.
         */
        public Location getLocationAt(int currentServerTick, int pingInTicks) {
            int targetTick = currentServerTick - pingInTicks;

            // Try to get exact match
            if (history.containsKey(targetTick)) {
                return history.get(targetTick);
            }

            // Fallback: Find closest tick (basic interpolation)
            // Since this is a simple map, we just return the oldest if lag is huge,
            // or the newest if lag is negative (impossible but safe).
            if (!history.isEmpty()) {
                // If we requested a time older than what we have, return oldest
                Integer oldestTick = history.keySet().iterator().next();
                if (targetTick < oldestTick) return history.get(oldestTick);

                // Otherwise return most recent (best guess)
                return new ArrayList<>(history.values()).get(history.size() - 1);
            }

            return null;
        }

        private void cull(final int cap) {
            while (history.size() > cap) {
                Integer firstKey = history.keySet().iterator().next();
                history.remove(firstKey);
            }
        }
    }

    // Helper import for the fallback logic
    private java.util.ArrayList<Location> toList(java.util.Collection<Location> c) {
        return new java.util.ArrayList<>(c);
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\compensation\Scheduler.java
================================================================================


package ret.tawny.truthful.compensation;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.function.Consumer;

public final class Scheduler {

    private final HashMap<PacketType, List<PacketEvent>> events;

    private final HashMap<PacketType, List<Consumer<PacketEvent>>> dispatchers;

    /**
     * The Scheduler allows you to read a packet's data on post position update.
     * <p/>
     * This SHOULD not and CANNOT be used to read position updates
     * <p/>
     * It should be relied on to read data that is dependent on the real client state, ie rotation checks
     */
    public Scheduler() {
        this.events = new HashMap<>();
        this.dispatchers = new HashMap<>();
    }

    public void onPacket(final PacketEvent packetEvent) {
        if(RelMovePacketWrapper.isRelMove(packetEvent.getPacketType())) {
            for(final PacketType packetType : new ArrayList<>(dispatchers.keySet())) {
                if(packetType == null)
                    continue;

                final List<PacketEvent> packetEvents = this.events.get(packetType);
                if(packetEvents == null || packetEvents.isEmpty())
                    continue;

                final List<PacketEvent> matchingEvents = new ArrayList<>();
                for(final PacketEvent queued : packetEvents) {
                    if(queued.getPlayer() == packetEvent.getPlayer()) {
                        matchingEvents.add(queued);
                    }
                }

                if(matchingEvents.isEmpty())
                    continue;

                final List<Consumer<PacketEvent>> consumers = this.dispatchers.get(packetType);
                if(consumers == null || consumers.isEmpty())
                    continue;

                for(final Consumer<PacketEvent> consumer : consumers) {
                    for(final PacketEvent queued : matchingEvents) {
                        consumer.accept(queued);
                    }
                }

                packetEvents.removeAll(matchingEvents);
                if(packetEvents.isEmpty()) {
                    this.events.remove(packetType);
                }
            }

            return;
        }
        this.events.computeIfAbsent(packetEvent.getPacketType(), key -> new ArrayList<>()).add(packetEvent);
    }

    public void registerDispatcher(final Consumer<PacketEvent> consumer, final PacketType packetType) {
        this.dispatchers.putIfAbsent(packetType, new ArrayList<>());
        this.dispatchers.get(packetType).add(consumer);
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\config\api\Configuration.java
================================================================================


package ret.tawny.truthful.config.api;

import org.bukkit.configuration.file.FileConfiguration;
import ret.tawny.truthful.TruthfulPlugin;

public final class Configuration {

    private final FileConfiguration config;

    public Configuration(final TruthfulPlugin plugin) {
        plugin.saveDefaultConfig();
        this.config = plugin.getConfig();
    }

    public boolean isCheckEnabled(String checkType, String checkOrder) {
        // This path matches the structure of the config.yml I provided.
        return this.config.getBoolean("checks." + checkType + "." + checkOrder + ".enabled", true);
    }

    public boolean isLagbacks() {
        return this.config.getBoolean("options.lagback", true);
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\data\DataManager.java
================================================================================


package ret.tawny.truthful.data;

import org.bukkit.entity.Player;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

public final class DataManager {
    private final Map<Player, PlayerData> players = new HashMap<>();

    public void enter(final Player player) {
        this.players.put(player, new PlayerData(player));
    }

    public void eliminate(final Player player) {
        this.players.remove(player);
    }

    public Collection<PlayerData> getCollection() {
        return this.players.values();
    }

    public PlayerData getPlayerData(final Player key) {
        return this.players.get(key);
    }

    public Map<Player, PlayerData> getPlayers() {
        return this.players;
    }

    public PlayerData getHighestPing() {
        long highestPing = 0;
        PlayerData laggiest = null;
        for (final PlayerData playerData : this.getCollection()) {
            final long ping = playerData.getPing();
            if (ping > highestPing) {
                highestPing = ping;
                laggiest = playerData;
            }
        }
        return laggiest;
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\data\PlayerData.java
================================================================================


package ret.tawny.truthful.data;

import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Player;
import org.bukkit.util.Vector;
import ret.tawny.truthful.sync.TeleportQueue;
import ret.tawny.truthful.sync.VelocityQueue;
import ret.tawny.truthful.utils.math.RollingAverage;
import ret.tawny.truthful.utils.world.WorldUtils;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;
import ret.tawny.truthful.wrapper.impl.server.position.SetPositionPacketWrapper;

public final class PlayerData {

    private final Player player;
    private boolean exempt = false;

    // --- NEW: Client Brand ---
    private String clientBrand = "Unknown"; // Default to Unknown

    private double x, lastX, deltaX, y, lastY, deltaY, lastDeltaY, z, lastZ, deltaZ, deltaXZ, lastDeltaXZ;
    private float yaw, lastYaw, deltaYaw, lastDeltaYaw, pitch, lastPitch, deltaPitch, lastDeltaPitch;
    private Location location, lastLocation, lastGroundLocation;
    private int vl, ticksTracked, ticksInAir, ticksOnGround, ticksSinceTeleport, ticksSinceAbility;
    private boolean onGround, lastGround, clientGround, lastClientGround;
    private boolean inLiquid, lastInLiquid, onClimbable, underBlock;
    private Entity lastTarget;
    private int currentSlot, lastSlot;
    private long ping;
    private long lastSlotSwitchTime, lastBlockPlaceTime;
    private int lastBlockPlaceTick;
    private int lastFireworkTick;
    private int lastGhostBlockTick;
    private int lastGlideTick;
    private int lastVehicleExitTick;

    private int lastWebTick;
    private boolean inWeb;

    private boolean nearVehicle;
    private boolean nearEntity;

    public final RollingAverage timerSpeed = new RollingAverage(20);
    private final VelocityQueue velocities = new VelocityQueue();
    private final TeleportQueue teleports = new TeleportQueue();

    public PlayerData(final Player player) {
        this.player = player;
        this.location = player.getLocation();
        this.lastLocation = player.getLocation();
        this.lastGroundLocation = player.getLocation();
        this.currentSlot = player.getInventory().getHeldItemSlot();
        this.lastSlot = player.getInventory().getHeldItemSlot();
        this.lastSlotSwitchTime = System.currentTimeMillis();
        this.lastBlockPlaceTime = -1L;
        this.lastFireworkTick = -100;
        this.lastGhostBlockTick = -100;
        this.lastGlideTick = -100;
        this.lastVehicleExitTick = -100;
        this.lastWebTick = -100;
    }

    public void update(final RelMovePacketWrapper event) {
        if (event.getPlayer() != this.player) return;

        this.ping = player.getPing();
        ++this.ticksTracked;
        ++this.ticksSinceTeleport;

        if (event.isPositionUpdate()) {
            if (teleports.match(event.getX(), event.getY(), event.getZ())) {
                this.ticksSinceTeleport = 0;
            }
        }
        if (this.ticksTracked % 100 == 0) teleports.cleanup();

        if (player.isGliding()) {
            this.lastGlideTick = this.ticksTracked;
        }

        this.inWeb = WorldUtils.isInWeb(player);
        if (this.inWeb) {
            this.lastWebTick = this.ticksTracked;
        }

        this.velocities.removeIf(velocity -> {
            velocity.tick();
            return velocity.hasReceived() && velocity.hasExpired();
        });

        this.lastLocation = this.location;
        this.lastX = this.x;
        this.lastY = this.y;
        this.lastZ = this.z;
        this.lastYaw = this.yaw;
        this.lastPitch = this.pitch;
        this.lastGround = this.onGround;
        this.lastClientGround = this.clientGround;
        this.lastDeltaY = this.deltaY;
        this.lastDeltaXZ = this.deltaXZ;
        this.lastDeltaYaw = this.deltaYaw;
        this.lastDeltaPitch = this.deltaPitch;
        this.lastInLiquid = this.inLiquid;

        this.location = new Location(player.getWorld(),
                event.isPositionUpdate() ? event.getX() : this.x,
                event.isPositionUpdate() ? event.getY() : this.y,
                event.isPositionUpdate() ? event.getZ() : this.z,
                event.isRotationUpdate() ? event.getYaw() : this.yaw,
                event.isRotationUpdate() ? event.getPitch() : this.pitch);

        this.x = this.location.getX();
        this.y = this.location.getY();
        this.z = this.location.getZ();
        this.yaw = this.location.getYaw();
        this.pitch = this.location.getPitch();

        this.deltaX = this.x - this.lastX;
        this.deltaY = this.y - this.lastY;
        this.deltaZ = this.z - this.lastZ;
        this.deltaYaw = this.yaw - this.lastYaw;
        this.deltaPitch = this.pitch - this.lastPitch;
        this.deltaXZ = Math.hypot(this.deltaX, this.deltaZ);

        this.onGround = WorldUtils.safeGround(player);
        this.clientGround = event.isGround();
        this.inLiquid = WorldUtils.isLiquid(player);
        this.onClimbable = WorldUtils.hasClimbableNearby(player);
        this.underBlock = WorldUtils.isSolid(player.getEyeLocation().clone().add(0, 0.5, 0).getBlock());

        if (this.onGround) {
            this.ticksOnGround++;
            this.ticksInAir = 0;
            this.lastGroundLocation = this.location;
        } else {
            this.ticksInAir++;
            this.ticksOnGround = 0;
        }
    }

    public void acceptTeleport(final SetPositionPacketWrapper positionPacketWrapper) {
        this.ticksSinceTeleport = 0;
        final World world = player.getWorld();
        final Location location = new Location(world,
                positionPacketWrapper.getX(),
                positionPacketWrapper.getY(),
                positionPacketWrapper.getZ());
        this.teleports.add(location);
    }

    public double getMaxVelocity() {
        double max = 0.0;
        for (VelocityQueue.Velocity v : this.velocities) {
            if (v.hasReceived() && !v.hasExpired()) {
                Vector vec = v.getVelocityVec();
                double horizontal = Math.sqrt(vec.getX() * vec.getX() + vec.getZ() * vec.getZ());
                if (horizontal > max)
                    max = horizontal;
            }
        }
        return max;
    }

    // --- GETTERS ---
    public Player getPlayer() { return this.player; }

    // Brand Getter/Setter
    public String getClientBrand() { return clientBrand; }
    public void setClientBrand(String clientBrand) { this.clientBrand = clientBrand; }

    public double getX() { return x; }
    public double getY() { return y; }
    public double getZ() { return z; }
    public float getYaw() { return yaw; }
    public float getLastYaw() { return lastYaw; }
    public float getPitch() { return pitch; }
    public float getLastPitch() { return lastPitch; }
    public int getVl() { return vl; }
    public int increment() { return ++vl; }
    public double getDeltaX() { return deltaX; }
    public double getDeltaY() { return deltaY; }
    public double getLastDeltaY() { return lastDeltaY; }
    public double getDeltaZ() { return deltaZ; }
    public double getDeltaXZ() { return deltaXZ; }
    public double getLastDeltaXZ() { return lastDeltaXZ; }
    public float getDeltaYaw() { return deltaYaw; }
    public float getLastDeltaYaw() { return lastDeltaYaw; }
    public float getDeltaPitch() { return deltaPitch; }
    public float getLastDeltaPitch() { return lastDeltaPitch; }
    public Location getLocation() { return location; }
    public Location getLastLocation() { return lastLocation; }
    public int getTicksInAir() { return ticksInAir; }
    public int getTicksOnGround() { return ticksOnGround; }
    public int getTicksTracked() { return ticksTracked; }
    public int getTicksSinceAbility() { return ticksSinceAbility; }
    public boolean isOnGround() { return onGround; }
    public boolean isLastGround() { return lastGround; }
    public Location getLastGroundLocation() { return lastGroundLocation; }
    public boolean isInLiquid() { return inLiquid; }
    public boolean wasInLiquid() { return lastInLiquid; }
    public boolean isUnderBlock() { return underBlock; }
    public boolean isOnClimbable() { return onClimbable; }
    public boolean isTeleportTick() { return ticksSinceTeleport <= 3; }
    public long getPing() { return ping; }
    public VelocityQueue getVelocities() { return velocities; }
    public long getLastBlockPlaceTime() { return lastBlockPlaceTime; }
    public void setLastBlockPlaceTime(long time) { this.lastBlockPlaceTime = time; }
    public int getLastBlockPlaceTick() { return lastBlockPlaceTick; }
    public void setLastBlockPlaceTick(int tick) { this.lastBlockPlaceTick = tick; }
    public long getLastSlotSwitchTime() { return lastSlotSwitchTime; }
    public void setLastSlotSwitchTime(long time) { this.lastSlotSwitchTime = time; }
    public Entity getLastTarget() { return lastTarget; }
    public void setLastTarget(Entity target) { this.lastTarget = target; }
    public int getCurrentSlot() { return currentSlot; }
    public void setCurrentSlot(int slot) { this.currentSlot = slot; }
    public int getLastSlot() { return lastSlot; }
    public void setLastSlot(int slot) { this.lastSlot = slot; }
    public int getLastFireworkTick() { return lastFireworkTick; }
    public void setLastFireworkTick(int tick) { this.lastFireworkTick = tick; }
    public int getLastGhostBlockTick() { return lastGhostBlockTick; }
    public void setLastGhostBlockTick(int tick) { this.lastGhostBlockTick = tick; }
    public int getLastGlideTick() { return lastGlideTick; }
    public boolean isExempt() { return exempt; }
    public void setExempt(boolean exempt) { this.exempt = exempt; }
    public boolean isNearVehicle() { return nearVehicle; }
    public void setNearVehicle(boolean nearVehicle) { this.nearVehicle = nearVehicle; }
    public boolean isNearEntity() { return nearEntity; }
    public void setNearEntity(boolean nearEntity) { this.nearEntity = nearEntity; }
    public int getLastVehicleExitTick() { return lastVehicleExitTick; }
    public void setLastVehicleExitTick(int tick) { this.lastVehicleExitTick = tick; }
    public int getLastWebTick() { return lastWebTick; }
    public boolean isInWeb() { return inWeb; }
    public void handleTransaction(short id) { this.velocities.confirm(id); }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\database\LogManager.java
================================================================================


package ret.tawny.truthful.database;

import org.bukkit.plugin.Plugin;
import java.io.File;
import java.io.PrintWriter;
import java.sql.*;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.UUID;

public final class LogManager {

    private Connection connection;
    private final Plugin plugin;

    public LogManager(Plugin plugin) {
        this.plugin = plugin;
        initialize();
    }

    private void initialize() {
        try {
            File dataFolder = new File(plugin.getDataFolder(), "database.db");
            if (!dataFolder.getParentFile().exists()) {
                dataFolder.getParentFile().mkdirs();
            }

            Class.forName("org.sqlite.JDBC");
            connection = DriverManager.getConnection("jdbc:sqlite:" + dataFolder.getAbsolutePath());

            try (Statement statement = connection.createStatement()) {
                statement.execute("CREATE TABLE IF NOT EXISTS violations (" +
                        "id INTEGER PRIMARY KEY AUTOINCREMENT, " +
                        "uuid VARCHAR(36), " +
                        "player VARCHAR(16), " +
                        "check_name VARCHAR(64), " +
                        "vl INTEGER, " +
                        "ping INTEGER, " +
                        "data TEXT, " +
                        "timestamp LONG);");
            }
        } catch (Exception e) {
            plugin.getLogger().severe("Failed to initialize SQLite database!");
            e.printStackTrace();
        }
    }

    public void log(UUID uuid, String playerName, String checkName, int vl, long ping, String debug) {
        // Standard Insert (Async run handled by caller or here if needed)
        // Note: Since we call this from async check threads often, direct execution is fine
        // if connection is thread-safe (SQLite single connection is usually fine for low volume)
        // But ideally, wrap in scheduler. For brevity in this snippet:
        try (PreparedStatement ps = connection.prepareStatement(
                "INSERT INTO violations (uuid, player, check_name, vl, ping, data, timestamp) VALUES(?,?,?,?,?,?,?);")) {
            ps.setString(1, uuid.toString());
            ps.setString(2, playerName);
            ps.setString(3, checkName);
            ps.setInt(4, vl);
            ps.setLong(5, ping);
            ps.setString(6, debug);
            ps.setLong(7, System.currentTimeMillis());
            ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public List<LogEntry> getLogs(String playerName, int limit) {
        List<LogEntry> logs = new ArrayList<>();
        try (PreparedStatement ps = connection.prepareStatement(
                "SELECT * FROM violations WHERE player = ? ORDER BY timestamp DESC LIMIT ?;")) {
            ps.setString(1, playerName);
            ps.setInt(2, limit);
            ResultSet rs = ps.executeQuery();

            while (rs.next()) {
                logs.add(new LogEntry(
                        rs.getString("player"),
                        rs.getString("check_name"),
                        rs.getInt("vl"),
                        rs.getString("data"),
                        rs.getLong("timestamp")
                ));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return logs;
    }

    // --- NEW EXPORT FEATURE ---
    public File exportToCsv() {
        File exportFolder = new File(plugin.getDataFolder(), "exports");
        if (!exportFolder.exists()) exportFolder.mkdirs();

        String fileName = "logs-" + new SimpleDateFormat("yyyy-MM-dd-HH-mm").format(new Date()) + ".csv";
        File file = new File(exportFolder, fileName);

        try (PrintWriter writer = new PrintWriter(file);
             Statement statement = connection.createStatement();
             ResultSet rs = statement.executeQuery("SELECT * FROM violations ORDER BY timestamp DESC;")) {

            // CSV Header
            writer.println("ID,UUID,Player,Check,VL,Ping,Data,Timestamp,Date");

            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

            while (rs.next()) {
                long time = rs.getLong("timestamp");
                String dateStr = sdf.format(new Date(time));

                // Escape commas in data
                String safeData = rs.getString("data").replace(",", ";");

                writer.printf("%d,%s,%s,%s,%d,%d,%s,%d,%s%n",
                        rs.getInt("id"),
                        rs.getString("uuid"),
                        rs.getString("player"),
                        rs.getString("check_name"),
                        rs.getInt("vl"),
                        rs.getLong("ping"),
                        safeData,
                        time,
                        dateStr
                );
            }
            return file;

        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public void shutdown() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static class LogEntry {
        public final String player, check, data;
        public final int vl;
        public final long timestamp;

        public LogEntry(String player, String check, int vl, String data, long timestamp) {
            this.player = player;
            this.check = check;
            this.vl = vl;
            this.data = data;
            this.timestamp = timestamp;
        }
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\event\api\IEvent.java
================================================================================


package ret.tawny.truthful.event.api;

public interface IEvent {
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\event\impl\ServerTickEvent.java
================================================================================


package ret.tawny.truthful.event.impl;

import ret.tawny.truthful.event.api.IEvent;

public final class ServerTickEvent implements IEvent {

}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\gui\GuiManager.java
================================================================================


package ret.tawny.truthful.gui;

import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.database.LogManager;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.List;

public class GuiManager implements Listener {

    public GuiManager() {
        Bukkit.getPluginManager().registerEvents(this, Truthful.getInstance().getPlugin());
    }

    public void openMainMenu(Player player) {
        Inventory inv = Bukkit.createInventory(null, 27, "¬ßcTruthful ¬ß8> ¬ß7Menu");

        fillGlass(inv);

        ItemStack info = createItem(Material.BOOK, "¬ßc¬ßlPlugin Info", "¬ß7Version: 2.1", "¬ß7Author: Tawny");
        ItemStack logs = createItem(Material.PAPER, "¬ß6¬ßlView Logs", "¬ß7Click to view recent logs", "¬ß7from current players.");
        ItemStack reload = createItem(Material.REDSTONE_BLOCK, "¬ßc¬ßlReload Config", "¬ß7Click to reload configuration.");

        inv.setItem(11, info);
        inv.setItem(13, logs);
        inv.setItem(15, reload);

        player.openInventory(inv);
    }

    public void openPlayerSelector(Player admin) {
        Inventory inv = Bukkit.createInventory(null, 54, "¬ßcTruthful ¬ß8> ¬ß7Select Player");

        for (Player target : Bukkit.getOnlinePlayers()) {
            ItemStack skull = createItem(Material.PLAYER_HEAD, "¬ßc" + target.getName(), "¬ß7Click to view history");
            inv.addItem(skull);
        }

        admin.openInventory(inv);
    }

    public void openLogs(Player admin, String targetName) {
        Inventory inv = Bukkit.createInventory(null, 54, "¬ßcLogs: " + targetName);

        // Run Async to prevent lag
        Bukkit.getScheduler().runTaskAsynchronously(Truthful.getInstance().getPlugin(), () -> {
            List<LogManager.LogEntry> logs = Truthful.getInstance().getLogManager().getLogs(targetName, 45);
            SimpleDateFormat sdf = new SimpleDateFormat("MM-dd HH:mm");

            for (LogManager.LogEntry log : logs) {
                String date = sdf.format(new Date(log.timestamp));
                ItemStack item = createItem(Material.PAPER,
                        "¬ßc" + log.check,
                        "¬ß7VL: ¬ßf" + log.vl,
                        "¬ß7Time: ¬ßf" + date,
                        "¬ß7Data: ¬ßf" + log.data
                );
                inv.addItem(item);
            }

            // Re-open sync
            Bukkit.getScheduler().runTask(Truthful.getInstance().getPlugin(), () -> admin.openInventory(inv));
        });
    }

    @EventHandler
    public void onClick(InventoryClickEvent e) {
        if (!e.getView().getTitle().startsWith("¬ßcTruthful")) return;
        e.setCancelled(true);
        if (e.getCurrentItem() == null) return;

        Player p = (Player) e.getWhoClicked();
        String title = e.getView().getTitle();
        ItemStack item = e.getCurrentItem();

        if (title.endsWith("Menu")) {
            if (item.getType() == Material.PAPER) {
                openPlayerSelector(p);
            } else if (item.getType() == Material.REDSTONE_BLOCK) {
                Truthful.getInstance().getPlugin().reloadConfig();
                p.sendMessage("¬ßaConfiguration reloaded.");
                p.closeInventory();
            }
        } else if (title.endsWith("Select Player")) {
            if (item.getType() == Material.PLAYER_HEAD) {
                String target = ChatColor.stripColor(item.getItemMeta().getDisplayName());
                openLogs(p, target);
            }
        }
    }

    private void fillGlass(Inventory inv) {
        ItemStack glass = createItem(Material.GRAY_STAINED_GLASS_PANE, " ");
        for (int i = 0; i < inv.getSize(); i++) {
            if (inv.getItem(i) == null) inv.setItem(i, glass);
        }
    }

    private ItemStack createItem(Material mat, String name, String... lore) {
        ItemStack item = new ItemStack(mat);
        ItemMeta meta = item.getItemMeta();
        if (meta != null) {
            meta.setDisplayName(name);
            meta.setLore(Arrays.asList(lore));
            item.setItemMeta(meta);
        }
        return item;
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\listener\PacketListener.java
================================================================================


package ret.tawny.truthful.listener;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.ProtocolLibrary;
import com.comphenix.protocol.events.ListenerPriority;
import com.comphenix.protocol.events.PacketAdapter;
import com.comphenix.protocol.events.PacketContainer;
import com.comphenix.protocol.events.PacketEvent;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.util.Vector;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.checks.registry.CheckRegistry;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.sync.VelocityQueue;
import ret.tawny.truthful.utils.ServerUtils;
import ret.tawny.truthful.wrapper.impl.client.position.RelMovePacketWrapper;

import java.nio.charset.StandardCharsets;

public final class PacketListener {

    public PacketListener(final CheckRegistry checkManager) {
        ProtocolLibrary.getProtocolManager().addPacketListener(new PacketAdapter(Truthful.getInstance().getPlugin(), ListenerPriority.HIGH,
                PacketType.Play.Client.ABILITIES,
                PacketType.Play.Client.BLOCK_DIG,
                PacketType.Play.Client.BLOCK_PLACE,
                PacketType.Play.Client.USE_ITEM,
                PacketType.Play.Client.CUSTOM_PAYLOAD,
                PacketType.Play.Client.ENTITY_ACTION,
                PacketType.Play.Client.FLYING,
                PacketType.Play.Client.POSITION,
                PacketType.Play.Client.POSITION_LOOK,
                PacketType.Play.Client.LOOK,
                PacketType.Play.Client.HELD_ITEM_SLOT,
                PacketType.Play.Client.ARM_ANIMATION,
                PacketType.Play.Client.SPECTATE,
                PacketType.Play.Client.TRANSACTION,
                PacketType.Play.Server.ENTITY_VELOCITY,
                PacketType.Play.Server.ENTITY_TELEPORT,
                PacketType.Play.Server.POSITION
        ) {
            @Override
            public void onPacketReceiving(final PacketEvent event) {
                final Player player = event.getPlayer();
                if (player == null) return;

                final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);
                if (data == null) return;

                // --- BRAND DETECTION ---
                if (event.getPacketType() == PacketType.Play.Client.CUSTOM_PAYLOAD) {
                    PacketContainer packet = event.getPacket();
                    String channel = "unknown";

                    // 1. Resolve Channel Name
                    try {
                        if (packet.getMinecraftKeys().size() > 0) {
                            channel = packet.getMinecraftKeys().read(0).getKey(); // Modern (minecraft:brand)
                        } else if (packet.getStrings().size() > 0) {
                            channel = packet.getStrings().read(0); // Legacy (MC|Brand)
                        }
                    } catch (Exception ignored) {}

                    if ("brand".equals(channel) || "MC|Brand".equals(channel)) {
                        byte[] payload = null;

                        // 2. Extract Payload Data (Try byte[] first, then ByteBuf)
                        if (packet.getByteArrays().size() > 0) {
                            payload = packet.getByteArrays().read(0);
                        } else if (packet.getSpecificModifier(ByteBuf.class).size() > 0) {
                            ByteBuf buf = packet.getSpecificModifier(ByteBuf.class).read(0).copy();
                            try {
                                payload = new byte[buf.readableBytes()];
                                buf.readBytes(payload);
                            } finally {
                                buf.release();
                            }
                        }

                        if (payload != null) {
                            // 3. Decode String
                            try {
                                // Wrap in Netty buffer to safely read the String (handles VarInt length)
                                // Or simple clean cleanup if raw
                                String rawBrand = new String(payload, StandardCharsets.UTF_8);
                                String cleanBrand = rawBrand.replaceAll("[^\\x20-\\x7E]", "").trim();

                                if (cleanBrand.length() > 1) {
                                    data.setClientBrand(cleanBrand);

                                    String msg = String.format("¬ß8[¬ßcTruthful¬ß8] ¬ß7Client Brand: ¬ßc%s ¬ß7using ¬ßf%s", player.getName(), cleanBrand);

                                    // Log to Console
                                    Bukkit.getLogger().info("[Truthful] Brand detected: " + player.getName() + " -> " + cleanBrand);

                                    // Alert Staff
                                    Bukkit.getScheduler().runTask(Truthful.getInstance().getPlugin(), () -> {
                                        for (Player staff : Bukkit.getOnlinePlayers()) {
                                            if (staff.hasPermission("truthful.alerts")) {
                                                staff.sendMessage(msg);
                                            }
                                        }
                                    });
                                }
                            } catch (Exception ignored) {}
                        }
                    }
                }
                // --- END BRAND ---

                Truthful.getInstance().getPlayerListener().onPacket(event);
                checkManager.getCollection().forEach(check -> check.onPacketPlayerReceive(event));

                if (RelMovePacketWrapper.isRelMove(event.getPacketType())) {
                    final RelMovePacketWrapper relMovePacketWrapper = new RelMovePacketWrapper(event);
                    data.update(relMovePacketWrapper);
                    checkManager.getCollection().forEach(check -> check.onRelMove(relMovePacketWrapper));
                }
            }

            @Override
            public void onPacketSending(final PacketEvent event) {
                final Player player = event.getPlayer();
                if (player == null) return;

                final PlayerData data = Truthful.getInstance().getDataManager().getPlayerData(player);
                if (data == null) return;

                if (event.getPacketType() == PacketType.Play.Server.ENTITY_VELOCITY) {
                    int entityId = event.getPacket().getIntegers().read(0);

                    if (entityId == player.getEntityId()) {
                        double x = event.getPacket().getIntegers().read(1) / 8000.0D;
                        double y = event.getPacket().getIntegers().read(2) / 8000.0D;
                        double z = event.getPacket().getIntegers().read(3) / 8000.0D;

                        int pingTicks = ServerUtils.getTickDelay(data);
                        data.getVelocities().add(new VelocityQueue.Velocity(new Vector(x, y, z), pingTicks, (short) 0));
                    }
                }

                Truthful.getInstance().getPlayerListener().onPacket(event);
                checkManager.getCollection().forEach(check -> check.onPacketPlaySend(event));
            }
        });
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\listener\PlayerListener.java
================================================================================


package ret.tawny.truthful.listener;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.event.player.PlayerBucketEmptyEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.event.vehicle.VehicleExitEvent; // New Import
import org.bukkit.inventory.ItemStack;
import ret.tawny.truthful.Truthful;
import ret.tawny.truthful.data.DataManager;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.wrapper.impl.client.action.PlayerItemSwitchPacketWrapper;
import ret.tawny.truthful.wrapper.impl.server.position.SetPositionPacketWrapper;

public final class PlayerListener implements Listener {

    private final DataManager dataManager;

    public PlayerListener() {
        this.dataManager = Truthful.getInstance().getDataManager();
        Bukkit.getPluginManager().registerEvents(this, Truthful.getInstance().getPlugin());
    }

    @EventHandler
    public void onJoin(final PlayerJoinEvent event) {
        this.dataManager.enter(event.getPlayer());
    }

    @EventHandler
    public void onQuit(final PlayerQuitEvent event) {
        this.dataManager.eliminate(event.getPlayer());
    }

    // --- FIX: VEHICLE EXIT DETECTION ---
    @EventHandler
    public void onVehicleExit(VehicleExitEvent event) {
        if (event.getExited() instanceof Player player) {
            PlayerData data = this.dataManager.getPlayerData(player);
            if (data != null) {
                // Record the tick when they exited the boat/cart
                data.setLastVehicleExitTick(data.getTicksTracked());
            }
        }
    }

    @EventHandler
    public void onAttack(final EntityDamageByEntityEvent event) {
        if (!(event.getDamager() instanceof Player damager)) return;
        if (Truthful.getInstance().isBedrockPlayer(damager)) return;

        final PlayerData data = this.dataManager.getPlayerData(damager);
        if (data == null) return;
        data.setLastTarget(event.getEntity());
    }

    @EventHandler
    public void onInteract(PlayerInteractEvent event) {
        Player player = event.getPlayer();
        ItemStack item = event.getItem();
        if (item != null && item.getType().name().contains("FIREWORK")) {
            final PlayerData data = this.dataManager.getPlayerData(player);
            if (data != null) data.setLastFireworkTick(data.getTicksTracked());
        }
    }

    @EventHandler(priority = EventPriority.MONITOR)
    public void onBlockPlace(BlockPlaceEvent event) {
        if (event.isCancelled()) {
            PlayerData data = this.dataManager.getPlayerData(event.getPlayer());
            if (data != null) {
                data.setLastGhostBlockTick(data.getTicksTracked());
            }
        }
    }

    @EventHandler(priority = EventPriority.MONITOR)
    public void onBucketEmpty(PlayerBucketEmptyEvent event) {
        if (event.isCancelled()) {
            PlayerData data = this.dataManager.getPlayerData(event.getPlayer());
            if (data != null) {
                data.setLastGhostBlockTick(data.getTicksTracked());
            }
        }
    }

    public void onPacket(final PacketEvent packetEvent) {
        if (Truthful.getInstance().isBedrockPlayer(packetEvent.getPlayer())) return;

        Truthful.getInstance().getScheduler().onPacket(packetEvent);

        final Player player = packetEvent.getPlayer();
        final PlayerData playerData = Truthful.getInstance().getDataManager().getPlayerData(player);

        if (playerData == null) return;

        if (packetEvent.getPacketType().isClient()) {
            if (packetEvent.getPacketType().equals(PacketType.Play.Client.HELD_ITEM_SLOT)) {
                final PlayerItemSwitchPacketWrapper itemSwitchPacketWrapper = new PlayerItemSwitchPacketWrapper(packetEvent);
                playerData.setLastSlot(playerData.getCurrentSlot());
                playerData.setCurrentSlot(itemSwitchPacketWrapper.getSlot());
                playerData.setLastSlotSwitchTime(System.currentTimeMillis());
            } else if (packetEvent.getPacketType().equals(PacketType.Play.Client.BLOCK_PLACE)) {
                playerData.setLastBlockPlaceTime(System.currentTimeMillis());
                playerData.setLastBlockPlaceTick(playerData.getTicksTracked());
            }
        } else {
            if (packetEvent.getPacketType().equals(PacketType.Play.Server.POSITION)) {
                final SetPositionPacketWrapper setPositionPacketWrapper = new SetPositionPacketWrapper(packetEvent);
                playerData.acceptTeleport(setPositionPacketWrapper);
            }
        }
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\sync\TeleportQueue.java
================================================================================


package ret.tawny.truthful.sync;

import org.bukkit.Location;
import org.bukkit.util.Vector;
import java.util.concurrent.ConcurrentLinkedDeque;

public final class TeleportQueue {

    private final ConcurrentLinkedDeque<Teleport> queue = new ConcurrentLinkedDeque<>();

    public void add(Location location) {
        queue.add(new Teleport(location));
    }

    /**
     * Checks if the given coordinates match a pending teleport in the queue.
     * If a match is found, it removes the teleport and returns true.
     */
    public boolean match(double x, double y, double z) {
        // We use an iterator to safely remove the item if found
        var iterator = queue.iterator();

        while (iterator.hasNext()) {
            Teleport tp = iterator.next();

            // Check distance. Clients sometimes snap to grid, so we allow a small error (0.05 blocks)
            double distSq = Math.pow(tp.x - x, 2) + Math.pow(tp.y - y, 2) + Math.pow(tp.z - z, 2);

            if (distSq < 0.0025) { // 0.05 * 0.05
                iterator.remove();
                return true;
            }
        }
        return false;
    }

    // Cleanup old teleports that were never confirmed (lagged out/cancelled)
    public void cleanup() {
        long now = System.currentTimeMillis();
        queue.removeIf(tp -> now - tp.timestamp > 5000); // Remove after 5 seconds
    }

    private static class Teleport {
        final double x, y, z;
        final long timestamp;

        Teleport(Location loc) {
            this.x = loc.getX();
            this.y = loc.getY();
            this.z = loc.getZ();
            this.timestamp = System.currentTimeMillis();
        }
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\sync\VelocityQueue.java
================================================================================


package ret.tawny.truthful.sync;

import org.bukkit.util.Vector;
import ret.tawny.truthful.utils.tick.ITickable;

import java.util.concurrent.ConcurrentLinkedDeque;

public final class VelocityQueue extends ConcurrentLinkedDeque<VelocityQueue.Velocity> {

    public static final class Velocity implements ITickable {
        private final Vector velocityVec;
        private int initialDelay;
        private int ticksExisted;
        private final short transactionId;
        private boolean received;

        public Velocity(final Vector velocityVec, final int initialDelay, final short transactionId) {
            this.velocityVec = velocityVec;
            this.initialDelay = initialDelay;
            this.transactionId = transactionId;
            this.ticksExisted = 0;
            this.received = false;
        }

        public Vector getVelocityVec() {
            return velocityVec;
        }

        public short getTransactionId() {
            return transactionId;
        }

        public void setReceived() {
            this.received = true;
        }

        @Override
        public void tick() {
            if (this.initialDelay > 0) {
                --this.initialDelay;
            } else {
                ++this.ticksExisted;
            }
        }

        public boolean hasReceived() {
            // Received if transaction confirmed OR timeout (fallback to ping-based delay)
            return this.received || this.initialDelay <= 0;
        }

        public boolean hasExpired() {
            return this.ticksExisted > 40;
        }
    }

    public void confirm(short id) {
        for (Velocity v : this) {
            if (v.getTransactionId() == id) {
                v.setReceived();
                // If confirmed, we can set delay to 0 to start ticking existence immediately
                v.initialDelay = 0;
            }
        }
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\SafeLocation.java
================================================================================


package ret.tawny.truthful.utils;

import org.bukkit.Location;
import org.bukkit.World;

public final class SafeLocation extends Location {
    public SafeLocation(final World world, final double x, final double y, final double z) {
        super(world, x, y, z);
    }
    public SafeLocation(final Location clone) {
        super(clone.getWorld(), clone.getX(), clone.getY(), clone.getZ());
    }

    public SafeLocation add(final Location vector) {
        return new SafeLocation(this.getWorld(), this.getX() + vector.getX(), this.getY() + vector.getY(), this.getZ() + vector.getZ());
    }
    public SafeLocation add(final SafeLocation vector) {
        return new SafeLocation(this.getWorld(), this.getX() + vector.getX(), this.getY() + vector.getY(), this.getZ() + vector.getZ());
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\ServerUtils.java
================================================================================


package ret.tawny.truthful.utils;

import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import ret.tawny.truthful.data.PlayerData;

public final class ServerUtils {
    private ServerUtils(){}

    public static void kick(final Player player, final String reason) {
        player.kickPlayer(reason);
    }

    public static void ban(final Player player, final String reason) {
        Bukkit.getServer().banIP(player.getAddress().getHostString());
    }

    /**
     *
     * @return Rounded tick delay from a player based on ping, eg 130 ping would be 2 ticks behind, or 270 would be 5 ticks behind
     */
    public static int getTickDelay(final PlayerData playerData) {
        return Math.round(playerData.getPing() / 50.0F);
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\VectorUtils.java
================================================================================


package ret.tawny.truthful.utils;

import org.bukkit.util.Vector;
import ret.tawny.truthful.data.PlayerData;
import ret.tawny.truthful.utils.math.MathHelper;
import ret.tawny.truthful.utils.math.VanillaMathHelper;

public final class VectorUtils {
    private VectorUtils() {}

    public static Vector getLookVector(final PlayerData playerData) {
        if (playerData.getTicksTracked() < 2) {
            return getVectorForRotation(playerData.getPitch(), playerData.getYaw());
        } else {
            float interpolatedPitch = playerData.getLastPitch() + (playerData.getPitch() - playerData.getLastPitch());
            float interpolatedYaw = playerData.getLastYaw() + (playerData.getYaw() - playerData.getLastYaw());
            return getVectorForRotation(interpolatedPitch, interpolatedYaw);
        }
    }

    public static Vector getVectorForRotation(final float pitch, final float yaw) {
        final float f = VanillaMathHelper.cos(-yaw * MathHelper.RADIAN - (float) Math.PI);
        final float f1 = VanillaMathHelper.sin(-yaw * MathHelper.RADIAN - (float) Math.PI);
        final float f2 = -VanillaMathHelper.cos(-pitch * MathHelper.RADIAN);
        final float f3 = VanillaMathHelper.sin(-pitch * MathHelper.RADIAN);
        return new Vector((f1 * f2), f3, (f * f2));
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\annot\NonNullable.java
================================================================================


package ret.tawny.truthful.utils.annot;

import java.lang.annotation.Retention;

import static java.lang.annotation.RetentionPolicy.SOURCE;

@Retention(SOURCE)
public @interface NonNullable {
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\annot\Nullable.java
================================================================================


package ret.tawny.truthful.utils.annot;

import static java.lang.annotation.RetentionPolicy.SOURCE;

import java.lang.annotation.Retention;

@Retention(SOURCE)
public @interface Nullable {
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\math\Kinematics.java
================================================================================


package ret.tawny.truthful.utils.math;

import org.bukkit.Location;
import org.bukkit.util.Vector;

public final class Kinematics {
    private Kinematics() {}

    /**
     * Calculates the angle between the player's look direction and their actual movement direction on the XZ plane.
     * @param location The player's current location (containing their yaw).
     * @param deltaX The player's change in X.
     * @param deltaZ The player's change in Z.
     * @return The angle in degrees. Returns 0 if the player is not moving.
     */
    public static double getStrafeAngle(Location location, double deltaX, double deltaZ) {
        Vector moveDirection = new Vector(deltaX, 0, deltaZ);
        if (moveDirection.lengthSquared() == 0) {
            return 0.0;
        }

        Vector lookDirection = location.getDirection().setY(0);
        return Math.toDegrees(moveDirection.angle(lookDirection));
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\math\MathHelper.java
================================================================================


package ret.tawny.truthful.utils.math;

import ret.tawny.truthful.utils.vec.Vector2f;

public final class MathHelper {

    public static final float RADIAN = (float) (Math.PI / 180.0F);
    private static final long EXPANDER = 16777216L; // 2^24

    /**
     * Wraps an angle to the range -180 to 180.
     */
    public static float wrapAngleTo180_float(float value) {
        value = value % 360.0F;
        if (value >= 180.0F)
            value -= 360.0F;

        if (value < -180.0F)
            value += 360.0F;
        return value;
    }

    /**
     * Recursive GCD with a noise floor cutoff.
     * Used specifically for sensitivity analysis where the 'remainder' might not be
     * 0 due to float errors.
     */
    public static long getGcd(final long current, final long previous) {
        return (previous <= 16384L) ? current : getGcd(previous, current % previous);
    }

    /**
     * Standard Greatest Common Divisor.
     */
    public static long gcd(long a, long b) {
        return (b == 0) ? a : gcd(b, a % b);
    }

    /**
     * Helper to calculate GCD for floating point numbers using an expansion
     * multiplier.
     * 
     * @param current  The current delta.
     * @param previous The previous delta.
     * @return The estimated common divisor (sensitivity step).
     */
    public static double getGcd(final double current, final double previous) {
        long a = (long) (current * EXPANDER);
        long b = (long) (previous * EXPANDER);
        return (double) getGcd(a, b) / EXPANDER;
    }

    public static double pow(final double base, final double exponent) {
        double result = 1;
        if (exponent < 0)
            return result / pow(base, -exponent);

        for (int i = 0; i < exponent; ++i)
            result *= base;

        return result;
    }

    public static float pow(final float base, final float exponent) {
        float result = 1;
        if (exponent < 0)
            return result / pow(base, -exponent);

        for (int i = 0; i < exponent; ++i)
            result *= base;

        return result;
    }

    public static double[] distributeByWeight(final double base, final double... values) {
        final int size = values.length;
        final double[] weighted = new double[size];

        double sum = 0;
        for (final double d : values)
            sum += d;
        for (int i = 0; i < size; ++i)
            weighted[i] = base * (values[i] / (sum * 100.0F));
        return weighted;
    }

    public static float lerp(final float start, final float end, final float t) {
        return start * (1 - t) + end * t;
    }

    public static Vector2f quadraticBezier(final Vector2f p0, final Vector2f p1, final Vector2f p2, final float t) {
        if (t < 0 || t > 1)
            throw new IllegalArgumentException("t must be between 0 and 1");
        final float x = pow(1 - t, 2) * p0.getX() + (1 - t) * 2 * t * p1.getX() + t * t * p2.getX();
        final float y = pow(1 - t, 2) * p0.getY() + (1 - t) * 2 * t * p1.getY() + t * t * p2.getY();
        return new Vector2f(x, y);
    }

    public static float quadraticBezierPoint(final float p0, final float p1, final float p2, final float t) {
        if (t < 0 || t > 1)
            throw new IllegalArgumentException("t must be between 0 and 1");
        return (float) (pow(1 - t, 2) * p0 + (1 - t) * 2 * t * p1 + t * t * p2);
    }

    public static Vector2f dynamicBezier(final float t, final Vector2f... ctrlPoints) {
        final int size = ctrlPoints.length;
        if (size < 2)
            throw new IllegalArgumentException("A bezier curve requires at least 2 control points");
        if (t < 0 || t > 1)
            throw new IllegalArgumentException("t must be between 0 and 1");

        float x = 0;
        float y = 0;

        int n = size - 1;
        for (int i = 0; i <= n; i++) {
            final double b = binomialCoefficient(n, i) * Math.pow(1 - t, n - i) * Math.pow(t, i);
            x += b * ctrlPoints[i].getX();
            y += b * ctrlPoints[i].getY();
        }
        return new Vector2f(x, y);
    }

    public static double binomialCoefficient(final int n, final int k) {
        double c = 1;
        for (int i = 0; i < k; ++i)
            c = c * (n - i) / (i + 1);
        return c;
    }

    public static double getMean(java.util.List<Integer> values) {
        if (values.isEmpty())
            return 0.0;
        double sum = 0.0;
        for (int val : values) {
            sum += val;
        }
        return sum / values.size();
    }

    public static double getVariance(java.util.List<Integer> values) {
        if (values.isEmpty())
            return 0.0;
        double mean = getMean(values);
        double temp = 0;
        for (int val : values) {
            temp += (val - mean) * (val - mean);
        }
        return temp / values.size();
    }

    public static double getSkewness(java.util.List<Integer> values) {
        if (values.isEmpty())
            return 0.0;
        double mean = getMean(values);
        double variance = getVariance(values);
        double stdDev = Math.sqrt(variance);

        if (stdDev == 0)
            return 0.0;

        double sum = 0.0;
        for (int val : values) {
            sum += Math.pow(val - mean, 3);
        }
        return sum / (values.size() * Math.pow(stdDev, 3));
    }

    public static double getKurtosis(java.util.List<Integer> values) {
        if (values.isEmpty())
            return 0.0;
        double mean = getMean(values);
        double variance = getVariance(values);
        double stdDev = Math.sqrt(variance);

        if (stdDev == 0)
            return 0.0;

        double sum = 0.0;
        for (int val : values) {
            sum += Math.pow(val - mean, 4);
        }
        // Excess Kurtosis = (Moment4 / StdDev^4) - 3
        return (sum / (values.size() * Math.pow(stdDev, 4))) - 3.0;
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\math\RollingAverage.java
================================================================================


package ret.tawny.truthful.utils.math;

import java.util.ArrayDeque;
import java.util.Queue;

public final class RollingAverage {
    private final Queue<Double> samples = new ArrayDeque<>();
    private final int size;
    private double total = 0.0;

    public RollingAverage(int size) {
        this.size = size;
    }

    public void add(double x) {
        total += x;
        samples.add(x);
        if (samples.size() > size) {
            total -= samples.poll();
        }
    }

    public double getAverage() {
        if (samples.isEmpty()) {
            return 0.0;
        }
        return total / samples.size();
    }

    public boolean isFull() {
        return samples.size() >= size;
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\math\VanillaMathHelper.java
================================================================================


package ret.tawny.truthful.utils.math;

public final class VanillaMathHelper {
    private VanillaMathHelper() {}

    /**
     * A table of sin values computed from 0 (inclusive) to 2*pi (exclusive), with steps of 2*PI / 65536.
     */
    private static final float[] SIN_TABLE = new float[65536];
    /**
     * sin looked up in a table
     */
    public static float sin(float p_76126_0_)
    {
        return SIN_TABLE[(int)(p_76126_0_ * 10430.378F) & 65535];
    }

    /**
     * cos looked up in the sin table with the appropriate offset
     */
    public static float cos(float value)
    {
        return SIN_TABLE[(int)(value * 10430.378F + 16384.0F) & 65535];
    }

    public static float sqrt_float(float value)
    {
        return (float)Math.sqrt((double)value);
    }

    static
    {
        for (int i = 0; i < 65536; ++i)
        {
            SIN_TABLE[i] = (float)Math.sin((double)i * Math.PI * 2.0D / 65536.0D);
        }
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\network\Packets.java
================================================================================


package ret.tawny.truthful.utils.network;

public final class Packets {

}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\network\ServerUtils.java
================================================================================


package ret.tawny.truthful.utils.network;

public final class ServerUtils {
    private ServerUtils() {}
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\player\PlayerUtils.java
================================================================================


package ret.tawny.truthful.utils.player;

import org.bukkit.Location;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Player;
import org.bukkit.potion.PotionEffect;
import org.bukkit.potion.PotionEffectType;
import ret.tawny.truthful.data.PlayerData;

public final class PlayerUtils {
    private PlayerUtils() {}

    public static final double GRAVITY_ACCELERATION = 0.08D;
    public static final double AIR_DRAG = 0.9800000190734863D;
    public static final double JUMP_MOTION = 0.42F;

    public static PotionEffect getPotion(final PotionEffectType type, final PlayerData data) {
        for (final PotionEffect potionEffect : data.getPlayer().getActivePotionEffects()) {
            if (potionEffect.getType().equals(type)) {
                return potionEffect;
            }
        }
        return null;
    }

    public static float[] to(final PlayerData data, final PlayerData target) {
        final double x = data.getX(), z = data.getZ();
        final double targetX = target.getX(), targetZ = target.getZ();
        final double targetLastX = target.getLastLocation().getX(), targetLastZ = target.getLastLocation().getZ();

        final double intpX = targetX + (targetX - targetLastX) - x;
        final double intpZ = targetZ + (targetZ - targetLastZ) - z;

        final float yaw = (float) Math.toDegrees(Math.atan2(intpZ, intpX)) - 90;
        return new float[]{yaw, Math.abs(yaw - data.getYaw())};
    }

    /**
     * Calculates the horizontal (XZ plane) distance between a player and an entity.
     * @param playerData The data of the attacking player.
     * @param target The target entity.
     * @return The horizontal distance.
     */
    public static double getDistanceHz(final PlayerData playerData, final Entity target) {
        if (target == null) return 0;
        final Location targetLoc = target.getLocation();
        final double deltaX = playerData.getX() - targetLoc.getX();
        final double deltaZ = playerData.getZ() - targetLoc.getZ();
        return Math.sqrt(deltaX * deltaX + deltaZ * deltaZ);
    }

    /**
     * Calculates the vertical (Y axis) distance between a player and an entity.
     * @param playerData The data of the attacking player.
     * @param target The target entity.
     * @return The absolute vertical distance.
     */
    public static double getDistanceVert(final PlayerData playerData, final Entity target) {
        if (target == null) return 0;
        final Location targetLoc = target.getLocation();
        return Math.abs(playerData.getY() - targetLoc.getY());
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\player\PredictionUtils.java
================================================================================


package ret.tawny.truthful.utils.player;

import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.potion.PotionEffect;
import org.bukkit.potion.PotionEffectType;

public final class PredictionUtils {

    public static int getJumpBoostAmplifier(Player player) {
        for (PotionEffect effect : player.getActivePotionEffects()) {
            if (effect.getType().equals(PotionEffectType.JUMP_BOOST)) {
                return effect.getAmplifier() + 1;
            }
        }
        return 0;
    }

    public static int getSpeedAmplifier(Player player) {
        for (PotionEffect effect : player.getActivePotionEffects()) {
            if (effect.getType().equals(PotionEffectType.SPEED)) {
                return effect.getAmplifier() + 1;
            }
        }
        return 0;
    }

    public static int getSlownessAmplifier(Player player) {
        for (PotionEffect effect : player.getActivePotionEffects()) {
            if (effect.getType().equals(PotionEffectType.SLOWNESS)) {
                return effect.getAmplifier() + 1;
            }
        }
        return 0;
    }

    /**
     * Calculates the Base Movement Speed attribute of the player.
     * Default is roughly 0.28 for sprinting.
     */
    public static double getBaseSpeed(Player player) {
        // Start with base walk speed (approx 0.22ish in practice for checks)
        // We use 0.23 to be safe.
        double base = 0.23;

        if (player.isSprinting()) {
            base = 0.281; // Vanilla Sprint Speed
        }

        // Apply Speed Potion (20% per level)
        int speed = getSpeedAmplifier(player);
        if (speed > 0) {
            base *= 1.0 + (0.2 * speed);
        }

        // Apply Slowness Potion (15% per level)
        int slow = getSlownessAmplifier(player);
        if (slow > 0) {
            base *= Math.max(0.0, 1.0 - (0.15 * slow));
        }

        return base;
    }

    public static float getBlockFriction(World world, Location location) {
        // Check block under player
        Location down = location.clone().subtract(0, 1, 0);
        Block block = world.getBlockAt(down);

        // If that block is air (e.g. standing on a slab or carpet), check one lower
        if (block.getType() == Material.AIR) {
            block = world.getBlockAt(down.subtract(0, 1, 0));
        }

        String type = block.getType().name();
        // Ice variants
        if (type.contains("ICE")) return 0.98F;
        // Slime
        if (type.contains("SLIME")) return 0.8F;
        // Soul Sand (slower) - We don't lower friction for checks to prevent falses,
        // we only care about 'slippery' blocks that allow speed gain.

        // Standard block friction
        return 0.6F;
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\raycast\Ray.java
================================================================================


package ret.tawny.truthful.utils.raycast;

import org.bukkit.util.Vector;

public final class Ray {
    private final Vector home;

    private final double length;

    public Ray(final Vector home, final double length) {
        this.home = home;
        this.length = length;
    }

    public static boolean intersects(int[] A, int[] B, double[] P) {
        if (A[1] > B[1])
            return intersects(B, A, P);

        if (P[1] == A[1] || P[1] == B[1])
            P[1] += 0.0001;

        if (P[1] > B[1] || P[1] < A[1] || P[0] >= Math.max(A[0], B[0]))
            return false;

        if (P[0] < Math.min(A[0], B[0]))
            return true;

        double red = (P[1] - A[1]) / (double) (P[0] - A[0]);
        double blue = (B[1] - A[1]) / (double) (B[0] - A[0]);
        return red >= blue;
    }

    static boolean contains(int[][] points, double[] pnt) {
        boolean inside = false;
        int len = points.length;
        for (int i = 0; i < len; i++) {
            if (intersects(points[i], points[(i + 1) % len], pnt))
                inside = !inside;
        }
        return inside;
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\reflection\Manager.java
================================================================================


package ret.tawny.truthful.utils.reflection;

import org.bukkit.plugin.Plugin;
import org.reflections.Reflections;
import org.reflections.util.ConfigurationBuilder;
import org.reflections.util.FilterBuilder;
import ret.tawny.truthful.utils.annot.Nullable;

import java.lang.annotation.Annotation;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

public abstract class Manager<K, V> {
    protected final Map<K, V> map;

    protected Manager() {
        this.map = new HashMap<>();
    }

    /**
     * @param plugin The main plugin instance, used to get the correct classloader.
     * @param filter The type of class to look for.
     * @param pkge The package to look through.
     * @param annot The annotation that must be present in each class (can be null).
     */
    @SuppressWarnings("unchecked")
    protected final void register(final Plugin plugin, final Class<?> filter, final String pkge, @Nullable final Class<? extends Annotation> annot) {
        final ConfigurationBuilder configBuilder = new ConfigurationBuilder()
                .forPackage(pkge, plugin.getClass().getClassLoader()) // Provide the plugin's classloader
                .filterInputsBy(new FilterBuilder().includePackage(pkge));

        final Reflections reflect = new Reflections(configBuilder);

        for (final Class<?> clazz : reflect.getSubTypesOf(filter)) {
            if (annot != null && !clazz.isAnnotationPresent(annot)) {
                System.out.println(clazz + " is missing the @" + annot.getSimpleName());
                continue;
            }
            try {
                final V instance = (V) clazz.getDeclaredConstructor().newInstance();
                this.map.put((K) clazz, instance);
            } catch (final ReflectiveOperationException e) {
                e.printStackTrace();
            }
        }
    }

    public final Map<K, V> getMap() {
        return this.map;
    }

    public final Collection<V> getCollection() {
        return this.map.values();
    }

    public final V getValue(final K k) {
        return this.map.get(k);
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\tick\ITickable.java
================================================================================


package ret.tawny.truthful.utils.tick;

public interface ITickable {
    void tick();
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\tuple\Pair.java
================================================================================


package ret.tawny.truthful.utils.tuple;

public class Pair<A, B> {
    private final A a;

    private final B b;

    public Pair(final A a, final B b) {
        this.a = a;
        this.b = b;
    }

    public A getA() {
        return a;
    }

    public B getB() {
        return b;
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\tuple\Triplet.java
================================================================================


package ret.tawny.truthful.utils.tuple;

public class Triplet<A, B, C> {
    private final A a;

    private final B b;

    private final C c;

    public Triplet(final A a, final B b, final C c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }

    public A getA() {
        return a;
    }

    public B getB() {
        return b;
    }

    public C getC() {
        return c;
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\vec\Vector2d.java
================================================================================


package ret.tawny.truthful.utils.vec;

public final class Vector2d {
    private double x;
    private double y;

    public Vector2d(final double x, final double y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }

    public void setX(final double x) {
        this.x = x;
    }

    public void setY(final double y) {
        this.y = y;
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\vec\Vector2f.java
================================================================================


package ret.tawny.truthful.utils.vec;

public final class Vector2f {
    private float x;
    private float y;

    public Vector2f(final float x, final float y) {
        this.x = x;
        this.y = y;
    }

    public float getX() {
        return x;
    }

    public float getY() {
        return y;
    }

    public void setX(final float x) {
        this.x = x;
    }

    public void setY(final float y) {
        this.y = y;
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\world\BlockUtils.java
================================================================================


package ret.tawny.truthful.utils.world;

import org.bukkit.Material;
import org.bukkit.Tag;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.entity.Player;
import org.bukkit.util.BlockIterator;
import java.util.EnumSet;
import java.util.Locale;
import java.util.Set;

public final class BlockUtils {
    private BlockUtils() {}

    private static final Set<Material> WHOLE_BLOCKS = EnumSet.noneOf(Material.class);

    static {
        for (final Material material : Material.values()) {
            if (!material.isBlock()) {
                continue;
            }
            try {
                if (material.isOccluding()) {
                    WHOLE_BLOCKS.add(material);
                }
            } catch (NoSuchMethodError e) {
                if (material.isSolid()) {
                    WHOLE_BLOCKS.add(material);
                }
            }
        }
    }

    public static Block getRelativeBlock(final Block anchor, final BlockFace face) {
        return face == null ? anchor : anchor.getRelative(face);
    }

    public static Block getFirstBlockInSight(final Player player, final double length) {
        BlockIterator iterator = new BlockIterator(player.getEyeLocation(), 0, (int) Math.ceil(length));
        while (iterator.hasNext()) {
            Block block = iterator.next();
            if (block.getType().isSolid()) {
                return block;
            }
        }
        return null;
    }

    public static boolean isWholeBlock(final Material material) {
        return WHOLE_BLOCKS.contains(material);
    }

    public static boolean isAbnormal(final Material material) {
        return !isWholeBlock(material);
    }

    public static boolean isLowFriction(final Material material) {
        final String name = material.name().toUpperCase(Locale.ROOT);
        return name.contains("ICE") || name.contains("SLIME_BLOCK");
    }

    public static boolean isClimbable(final Material material) {
        try {
            if (Tag.CLIMBABLE.isTagged(material)) {
                return true;
            }
        } catch (NoClassDefFoundError | NoSuchMethodError ignored) {
            final String name = material.name();
            return name.equals("LADDER") || name.equals("VINE") || name.equals("SCAFFOLDING");
        }
        return false;
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\utils\world\WorldUtils.java
================================================================================


package ret.tawny.truthful.utils.world;

import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import java.util.EnumSet;
import java.util.Set;

public final class WorldUtils {
    private WorldUtils() {
    }

    private static final Set<Material> LOW_FRICTION = EnumSet.noneOf(Material.class);
    private static final Set<Material> PARTIAL_BLOCKS = EnumSet.noneOf(Material.class);
    private static final Set<Material> WEBS = EnumSet.noneOf(Material.class);

    static {
        for (Material mat : Material.values()) {
            String name = mat.name();
            if (name.contains("ICE") || name.contains("SLIME")) {
                LOW_FRICTION.add(mat);
            }
            if (name.contains("CARPET") || name.contains("TRAPDOOR") ||
                    name.contains("SLAB") || name.contains("STAIR") ||
                    name.contains("LILY") || name.contains("SNOW") ||
                    name.contains("SHULKER") || name.contains("BERRY")) {
                PARTIAL_BLOCKS.add(mat);
            }
            if (name.equals("WEB") || name.equals("COBWEB")) {
                WEBS.add(mat);
            }
        }
    }

    public static boolean safeGround(final Player player) {
        final Location loc = player.getLocation();

        // 1. Check Solid Block Below (Standard)
        if (checkBlock(getLocationBlock(loc.clone().add(0, -0.5, 0)))) return true;

        // 2. Check Thin Blocks at Feet Level (Lily Pads, Carpets, Snow)
        // These blocks sit at the same Y level as the player's feet.
        // The -0.5 check often misses them (hitting the water/block below).
        if (checkThinBlock(getLocationBlock(loc))) return true;

        // 3. Check Edges (Expansion)
        double expansion = 0.305;
        for (double x = -expansion; x <= expansion; x += expansion) {
            for (double z = -expansion; z <= expansion; z += expansion) {
                if (x == 0 && z == 0) continue;

                Location offset = loc.clone().add(x, 0, z);
                // Check below
                if (checkBlock(getLocationBlock(offset.clone().add(0, -0.5, 0)))) return true;
                // Check at feet
                if (checkThinBlock(getLocationBlock(offset))) return true;
            }
        }
        return false;
    }

    // Helper to detect thin blocks that players stand ON, not IN.
    private static boolean checkThinBlock(Block block) {
        if (block == null) return false;
        String name = block.getType().name();
        // LILY_PAD, CARPET, SNOW layers, etc.
        return name.contains("LILY") || name.contains("CARPET") || name.contains("SNOW") || name.contains("SLAB");
    }

    public static boolean isInWeb(Player player) {
        Location loc = player.getLocation();

        // 1. Below feet
        if (checkWeb(loc.clone().subtract(0, 0.5, 0))) return true;

        // 2. Feet Level (Corners)
        double r = 0.31;
        if (checkWeb(loc)) return true;
        if (checkWeb(loc.clone().add(r, 0, r))) return true;
        if (checkWeb(loc.clone().add(r, 0, -r))) return true;
        if (checkWeb(loc.clone().add(-r, 0, r))) return true;
        if (checkWeb(loc.clone().add(-r, 0, -r))) return true;

        // 3. Head/Torso Level
        Location head = loc.clone().add(0, 1.0, 0);
        if (checkWeb(head)) return true;
        if (checkWeb(head.clone().add(r, 0, r))) return true;
        if (checkWeb(head.clone().add(r, 0, -r))) return true;
        if (checkWeb(head.clone().add(-r, 0, r))) return true;
        if (checkWeb(head.clone().add(-r, 0, -r))) return true;

        return false;
    }

    private static boolean checkWeb(Location loc) {
        Block block = getLocationBlock(loc);
        return block != null && WEBS.contains(block.getType());
    }

    public static int getWorldTicks(World world) {
        return (int) world.getFullTime();
    }

    public static float getSlippinessMultiplier(Player player) {
        if (player.isFlying()) return 0.6f;

        Block block = getLocationBlock(player.getLocation().clone().subtract(0, 0.5, 0));
        if (block == null) return 0.6f;

        String type = block.getType().name();
        if (type.contains("ICE")) return 0.98f;
        if (type.contains("SLIME")) return 0.8f;
        return 0.6f;
    }

    public static boolean hasLowFrictionBelow(Player player) {
        Block block = getLocationBlock(player.getLocation().clone().subtract(0, 0.5, 0));
        if (block == null) return false;
        String type = block.getType().name();
        return type.contains("ICE") || type.contains("SLIME");
    }

    public static boolean checkBlock(Block block) {
        return block != null && block.getType().isSolid();
    }

    public static Block getLocationBlock(Location loc) {
        return loc.getWorld().getBlockAt(loc);
    }

    public static boolean isLiquid(Player player) {
        Block block = getLocationBlock(player.getLocation());
        return block != null && (block.getType().name().contains("WATER") || block.getType().name().contains("LAVA"));
    }

    public static boolean hasClimbableNearby(Player player) {
        Block block = getLocationBlock(player.getLocation());
        if (block == null) return false;
        String name = block.getType().name();
        return name.contains("LADDER") || name.contains("VINE") || name.contains("SCAFFOLDING");
    }

    public static boolean isSolid(Block block) {
        return block != null && block.getType().isSolid();
    }

    public static boolean nearBlock(Player player) {
        Location loc = player.getLocation();
        for (int x = -1; x <= 1; x++) {
            for (int z = -1; z <= 1; z++) {
                Block block = loc.clone().add(x, 0, z).getBlock();
                if (block != null && block.getType().isSolid())
                    return true;
                if (block != null && block.getType().name().contains("LILY"))
                    return true;
            }
        }
        return false;
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\version\IVersionAdapter.java
================================================================================


package ret.tawny.truthful.version;

import org.bukkit.entity.Player;

public interface IVersionAdapter {

    double getBaseGroundSpeed(Player player);

    double getBaseAirSpeed(Player player);

    boolean isBlocking(Player player);

    int getServerVersion();
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\version\VersionManager.java
================================================================================


package ret.tawny.truthful.version;

import org.bukkit.Bukkit;
import ret.tawny.truthful.version.impl.VersionAdapter_1_8;
import ret.tawny.truthful.version.impl.VersionAdapter_Modern;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public final class VersionManager {
    private IVersionAdapter adapter;

    public void load() {
        try {
            Pattern pattern = Pattern.compile("1\\.(\\d{1,2})");
            Matcher matcher = pattern.matcher(Bukkit.getServer().getBukkitVersion());

            if (matcher.find()) {
                int minorVersion = Integer.parseInt(matcher.group(1));

                if (minorVersion <= 8) {
                    this.adapter = new VersionAdapter_1_8();
                    Bukkit.getLogger().info("[Truthful] Loaded Version Adapter for Minecraft 1.8 compatibility.");
                } else {
                    this.adapter = new VersionAdapter_Modern(minorVersion);
                    Bukkit.getLogger().info("[Truthful] Loaded Version Adapter for modern Minecraft (1.9+).");
                }
            } else {
                throw new IllegalStateException("Could not determine server version from Bukkit version string: " + Bukkit.getServer().getBukkitVersion());
            }

        } catch (Exception e) {
            Bukkit.getLogger().severe("[Truthful] Failed to load a compatible version adapter! The plugin will be disabled.");
            e.printStackTrace();
            Bukkit.getPluginManager().disablePlugin(Bukkit.getPluginManager().getPlugin("Truthful"));
        }
    }

    public IVersionAdapter getAdapter() {
        if (this.adapter == null) {
            throw new IllegalStateException("Version adapter has not been loaded yet!");
        }
        return this.adapter;
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\version\impl\VersionAdapter_1_8.java
================================================================================


package ret.tawny.truthful.version.impl;

import org.bukkit.entity.Player;
import org.bukkit.potion.PotionEffect;
import org.bukkit.potion.PotionEffectType;
import ret.tawny.truthful.version.IVersionAdapter;

public final class VersionAdapter_1_8 implements IVersionAdapter {

    private static final double BASE_WALK_SPEED = 0.21585;
    private static final double BASE_SPRINT_SPEED = 0.2806;
    private static final double BASE_AIR_SPEED = 0.36;

    @Override
    public double getBaseGroundSpeed(Player player) {
        double max = player.isSprinting() ? BASE_SPRINT_SPEED : BASE_WALK_SPEED;
        if (player.hasPotionEffect(PotionEffectType.SPEED)) {
            int amplifier = getPotionAmplifier(player, PotionEffectType.SPEED);
            max *= 1.0 + (0.2 * amplifier);
        }
        return max;
    }

    @Override
    public double getBaseAirSpeed(Player player) {
        return BASE_AIR_SPEED;
    }

    @Override
    @SuppressWarnings("deprecation")
    public boolean isBlocking(Player player) {
        return player.isBlocking();
    }

    @Override
    public int getServerVersion() {
        return 8;
    }

    private int getPotionAmplifier(Player player, PotionEffectType type) {
        for (PotionEffect effect : player.getActivePotionEffects()) {
            if (effect.getType().equals(type)) {
                return effect.getAmplifier() + 1;
            }
        }
        return 0;
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\version\impl\VersionAdapter_Modern.java
================================================================================


package ret.tawny.truthful.version.impl;

import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import ret.tawny.truthful.version.IVersionAdapter;

public final class VersionAdapter_Modern implements IVersionAdapter {

    private final int version;

    public VersionAdapter_Modern(int version) {
        this.version = version;
    }

    @Override
    public double getBaseGroundSpeed(Player player) {
        float attributeSpeed = player.getWalkSpeed();
        double effectiveSpeed = (attributeSpeed / 0.2F) * 0.215;
        if (player.isSprinting()) {
            effectiveSpeed *= 1.3;
        }
        return effectiveSpeed;
    }

    @Override
    public double getBaseAirSpeed(Player player) {
        return 0.38;
    }

    @Override
    public boolean isBlocking(Player player) {
        ItemStack mainHand = player.getInventory().getItemInMainHand();
        ItemStack offHand = player.getInventory().getItemInOffHand();
        return player.isBlocking() && (mainHand.getType() == Material.SHIELD || offHand.getType() == Material.SHIELD);
    }

    @Override
    public int getServerVersion() {
        return this.version;
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\wrapper\api\PacketWrapper.java
================================================================================


package ret.tawny.truthful.wrapper.api;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketContainer;
import com.comphenix.protocol.events.PacketEvent;
import org.bukkit.entity.Player;

public abstract class PacketWrapper {
    protected final PacketContainer packetContainer;
    protected final Player player;
    protected final PacketType type;

    protected PacketWrapper(PacketEvent packetEvent) {
        this.packetContainer = packetEvent.getPacket();
        this.player = packetEvent.getPlayer();
        this.type = packetEvent.getPacketType();
    }

    public final Player getPlayer() {
        return player;
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\wrapper\impl\client\action\PlayerBlockPlacePacketWrapper.java
================================================================================


package ret.tawny.truthful.wrapper.impl.client.action;

import com.comphenix.protocol.events.PacketEvent;
import com.comphenix.protocol.wrappers.BlockPosition;
import com.comphenix.protocol.wrappers.EnumWrappers;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.util.Vector;
import ret.tawny.truthful.wrapper.api.PacketWrapper;

import java.util.List;

public final class PlayerBlockPlacePacketWrapper extends PacketWrapper {

    private final BlockPosition blockPosition;
    private final Block block;
    private final Vector hitVec;
    private final BlockFace blockFace;

    public PlayerBlockPlacePacketWrapper(final PacketEvent packetEvent) {
        super(packetEvent);
        final List<Float> pointsIn = this.packetContainer.getFloat().getValues();
        final float hitX = pointsIn.size() > 0 ? pointsIn.get(0) : 0.5F;
        final float hitY = pointsIn.size() > 1 ? pointsIn.get(1) : 0.5F;
        final float hitZ = pointsIn.size() > 2 ? pointsIn.get(2) : 0.5F;

        this.hitVec = new Vector(hitX, hitY, hitZ);

        this.blockFace = resolveFace();

        final List<BlockPosition> positions = this.packetContainer.getBlockPositionModifier().getValues();
        if (positions.isEmpty()) {
            final BlockPosition fallback = new BlockPosition(this.player.getLocation().getBlockX(),
                    this.player.getLocation().getBlockY(), this.player.getLocation().getBlockZ());
            this.blockPosition = fallback;
        } else {
            this.blockPosition = positions.get(0);
        }

        this.block = this.player.getWorld().getBlockAt(this.blockPosition.getX(),
                this.blockPosition.getY(), this.blockPosition.getZ());
    }

    private BlockFace resolveFace() {
        final EnumWrappers.Direction direction = readDirection();
        if (direction != null) {
            // Use a manual, robust mapping to convert ProtocolLib's enum to Bukkit's enum
            return mapDirectionToBlockFace(direction);
        }

        // Fallback for very old server versions
        final List<Integer> faces = this.packetContainer.getIntegers().getValues();
        final int faceIndex = faces.isEmpty() ? 255 : faces.get(0);
        return faceFromIndex(faceIndex);
    }

    // This new helper method provides a guaranteed conversion, fixing the error.
    private BlockFace mapDirectionToBlockFace(EnumWrappers.Direction direction) {
        if (direction == null) return null;
        return switch (direction) {
            case NORTH -> BlockFace.NORTH;
            case SOUTH -> BlockFace.SOUTH;
            case EAST -> BlockFace.EAST;
            case WEST -> BlockFace.WEST;
            case UP -> BlockFace.UP;
            case DOWN -> BlockFace.DOWN;
        };
    }

    private EnumWrappers.Direction readDirection() {
        // This logic attempts multiple ways to read the direction for maximum compatibility
        try {
            return this.packetContainer.getEnumModifier(EnumWrappers.Direction.class, 1).readSafely(0);
        } catch (final Throwable ignored) {
            try {
                return this.packetContainer.getDirections().readSafely(0);
            } catch (final Throwable ignored2) {
                return null;
            }
        }
    }

    private static BlockFace faceFromIndex(final int index) {
        return switch (index) {
            case 0 -> BlockFace.DOWN;
            case 1 -> BlockFace.UP;
            case 2 -> BlockFace.NORTH;
            case 3 -> BlockFace.SOUTH;
            case 4 -> BlockFace.WEST;
            case 5 -> BlockFace.EAST;
            default -> null; // Interact Scenario (index 255)
        };
    }

    public BlockPosition getBlockPosition() {
        return blockPosition;
    }

    public Block getBlock() {
        return block;
    }

    public BlockFace getBlockFace() {
        return blockFace;
    }

    public Vector getHitVec() {
        return hitVec;
    }

    @Override
    public String toString() {
        return String.format("PlayerBlockPlace[HitVector=%s, Facing=%s]", this.hitVec.toString(), this.blockFace);
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\wrapper\impl\client\action\PlayerDiggingPacketWrapper.java
================================================================================


package ret.tawny.truthful.wrapper.impl.client.action;

import com.comphenix.protocol.events.PacketEvent;
import ret.tawny.truthful.wrapper.api.PacketWrapper;

public final class PlayerDiggingPacketWrapper extends PacketWrapper {
    public PlayerDiggingPacketWrapper(final PacketEvent packetEvent) {
        super(packetEvent);
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\wrapper\impl\client\action\PlayerItemSwitchPacketWrapper.java
================================================================================


package ret.tawny.truthful.wrapper.impl.client.action;

import com.comphenix.protocol.events.PacketEvent;
import ret.tawny.truthful.wrapper.api.PacketWrapper;

import java.util.List;

public final class PlayerItemSwitchPacketWrapper extends PacketWrapper {
    /**
     * Slot the player is switching to on their hotbar
     */
    private final int slot;

    public PlayerItemSwitchPacketWrapper(final PacketEvent packetEvent) {
        super(packetEvent);
        final List<Integer> integersIn = packetContainer.getIntegers().getValues();
        this.slot = integersIn.get(0);
    }

    /**
     *
     * @return HotBar slot the player has switched too
     */
    public int getSlot() {
        return slot;
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\wrapper\impl\client\position\RelMovePacketWrapper.java
================================================================================


package ret.tawny.truthful.wrapper.impl.client.position;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.events.PacketEvent;
import org.bukkit.Location;
import ret.tawny.truthful.wrapper.api.PacketWrapper;

import java.util.List;

public final class RelMovePacketWrapper extends PacketWrapper {
    private final double x, y, z;
    private final float yaw, pitch;
    private final boolean ground;

    public RelMovePacketWrapper(final PacketEvent packetEvent) {
        super(packetEvent);
        final Location playerLoc = player.getLocation();

        List<Double> doublesIn = packetContainer.getDoubles().getValues();
        List<Float> floatsIn = packetContainer.getFloat().getValues();
        List<Boolean> booleansIn = packetContainer.getBooleans().getValues();

        this.x = !doublesIn.isEmpty() ? doublesIn.get(0) : playerLoc.getX();
        this.y = doublesIn.size() > 1 ? doublesIn.get(1) : playerLoc.getY();
        this.z = doublesIn.size() > 2 ? doublesIn.get(2) : playerLoc.getZ();

        this.yaw = !floatsIn.isEmpty() ? floatsIn.get(0) : playerLoc.getYaw();
        this.pitch = floatsIn.size() > 1 ? floatsIn.get(1) : playerLoc.getPitch();

        this.ground = !booleansIn.isEmpty() && booleansIn.get(0);
    }

    public static boolean isRelMove(final PacketType packetType) {
        // This method remains static because it's a general utility and doesn't depend on a specific packet instance.
        return packetType == PacketType.Play.Client.POSITION ||
                packetType == PacketType.Play.Client.POSITION_LOOK ||
                packetType == PacketType.Play.Client.LOOK ||
                packetType == PacketType.Play.Client.FLYING;
    }

    public double getX() { return x; }
    public double getY() { return y; }
    public double getZ() { return z; }
    public float getYaw() { return yaw; }
    public float getPitch() { return pitch; }

    /**
     * @return Client Ground State
     */
    // This method is now an instance method (non-static), which fixes the error.
    public boolean isGround() {
        return ground;
    }

    /**
     * @return Packet updates client position
     */
    public boolean isPositionUpdate() {
        return this.type == PacketType.Play.Client.POSITION || this.type == PacketType.Play.Client.POSITION_LOOK;
    }

    /**
     * @return Packet updates clients rotation state
     */
    public boolean isRotationUpdate() {
        return this.type == PacketType.Play.Client.LOOK || this.type == PacketType.Play.Client.POSITION_LOOK;
    }
}


================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\wrapper\impl\client\sync\ConfirmTransactionPacketWrapper.java
================================================================================


package ret.tawny.truthful.wrapper.impl.client.sync;

import com.comphenix.protocol.events.PacketEvent;
import ret.tawny.truthful.wrapper.api.PacketWrapper;

public final class ConfirmTransactionPacketWrapper extends PacketWrapper {
    /**
     * Window In ID, for example inventory is 0
     */
    private final int windowId;
    /**
     * Transaction ID
     */
    private final short uid;
    /**
     * Accepted should always be true when incoming
     */
    private final boolean accepted;

    public ConfirmTransactionPacketWrapper(final PacketEvent packetEvent) {
        super(packetEvent);
        this.windowId = this.packetContainer.getIntegers().getValues().get(0);
        this.uid = this.packetContainer.getShorts().getValues().get(0);
        this.accepted = this.packetContainer.getBooleans().getValues().get(0);
    }

    public int getWindowId() {
        return windowId;
    }

    public short getUid() {
        return uid;
    }

    public boolean isAccepted() {
        return accepted;
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\wrapper\impl\client\sync\KeepAlivePacketWrapper.java
================================================================================


package ret.tawny.truthful.wrapper.impl.client.sync;

import com.comphenix.protocol.events.PacketEvent;
import ret.tawny.truthful.wrapper.api.PacketWrapper;

public final class KeepAlivePacketWrapper extends PacketWrapper {
    /**
     * Keep Alive Response Key
     */
    private final int key;

    /**
     *
     * @param packetEvent - Inbound Keep Alive Packet Event
     */
    public KeepAlivePacketWrapper(final PacketEvent packetEvent) {
        super(packetEvent);
        this.key = this.packetContainer.getIntegers().getValues().get(0);
    }

    /**
     *
     * @return Keep Alive Key
     */
    public int getKey() {
        return key;
    }
}



================================================================================
FILE PATH: .\src\main\java\ret\tawny\truthful\wrapper\impl\server\position\SetPositionPacketWrapper.java
================================================================================


package ret.tawny.truthful.wrapper.impl.server.position;

import com.comphenix.protocol.events.PacketEvent;
import ret.tawny.truthful.wrapper.api.PacketWrapper;

import java.util.List;

public final class SetPositionPacketWrapper extends PacketWrapper {
    private final double x, y, z;
    private final float yaw, pitch;
    private final boolean ground;

    public SetPositionPacketWrapper(final PacketEvent packetEvent) {
        super(packetEvent);

        // This is the robust, correct way to safely read from ProtocolLib's structure modifiers.
        // We get the list of values and check the size before accessing an index.
        final List<Double> doublesIn = packetContainer.getDoubles().getValues();
        final List<Float> floatsIn = packetContainer.getFloat().getValues();
        final List<Boolean> booleansIn = packetContainer.getBooleans().getValues();

        this.x = !doublesIn.isEmpty() ? doublesIn.get(0) : player.getLocation().getX();
        this.y = doublesIn.size() > 1 ? doublesIn.get(1) : player.getLocation().getY();
        this.z = doublesIn.size() > 2 ? doublesIn.get(2) : player.getLocation().getZ();

        this.yaw = !floatsIn.isEmpty() ? floatsIn.get(0) : player.getLocation().getYaw();
        this.pitch = floatsIn.size() > 1 ? floatsIn.get(1) : player.getLocation().getPitch();

        this.ground = !booleansIn.isEmpty() && booleansIn.get(0);
    }

    /**
     * @return X Coordinate
     */
    public double getX() {
        return x;
    }

    /**
     * @return Y Coordinate
     */
    public double getY() {
        return y;
    }

    /**
     * @return Z Coordinate
     */
    public double getZ() {
        return z;
    }

    /**
     * @return Yaw Rotation
     */
    public float getYaw() {
        return yaw;
    }

    /**
     * @return Pitch Rotation
     */
    public float getPitch() {
        return pitch;
    }

    /**
     * @return Client Ground State
     * @deprecated Any hacked client can spoof a fake value. Use server-side checks.
     */
    @Deprecated
    public boolean isGround() {
        return ground;
    }

    @Override
    public String toString() {
        return String.format("SetPositionPacket[X=%.2f, Y=%.2f, Z=%.2f, Yaw=%.2f, Pitch=%.2f]",
                this.x, this.y, this.z, this.yaw, this.pitch);
    }
}


================================================================================
FILE PATH: .\src\main\resources\config.yml
================================================================================


# =================================================================================== #
#                                 TRUTHFUL ANTI-CHEAT                                 #
# =================================================================================== #
#
#  Configuration Guide:
#  - enabled: true/false -> Toggles the specific check on or off.
#
#  Note: Bedrock players (via Floodgate) are automatically exempt from all checks
#  if the Floodgate plugin is detected.
# =================================================================================== #

options:
  # If true, the plugin will attempt to teleport players back to their last valid
  # location when they fail movement checks (Fly, Speed, Jesus).
  lagback: true

checks:
  # ------------------------------------------------------------------------------- #
  # MOVEMENT CHECKS
  # ------------------------------------------------------------------------------- #
  FLY:
    A: # Kinetic Energy & Gravity prediction. Detects Flight and weird jumps.
      enabled: true

  ELYTRA:
    A: # Infinite Flight / Force Height detection.
      enabled: true
    B: # Energy Conservation. Detects gaining speed while rising without fireworks.
      enabled: true
    C: # Glide Ratio. Detects "Cruise Control" / Maintaining altitude while flying fast.
      enabled: true
    D: # Acceleration. Detects speed gain without diving or fireworks.
      enabled: true
    E: # Kinetic Control. Detects impossible turns and strafing while flying.
      enabled: true
    F: # Pitch/Speed Limit. Prevents going fast while looking up/flat.
      enabled: true
    G: # Vector Alignment. Prevents flying sideways/backwards relative to look direction.
      enabled: true

  SPEED:
    A: # Speed Limit. Enforces max vanilla walking/sprinting speeds + friction.
      enabled: true
    B: # Momentum Analysis. Detects if a player accelerates faster than physics allow.
      enabled: true
    C: # Air Acceleration. Detects abnormal speed buildup while jumping.
      enabled: true

  STRAFE:
    A: # Air Control. Detects changing direction mid-air instantly (impossible physics).
      enabled: true

  JESUS:
    A: # Water/Liquid check. Detects walking on water or moving too fast inside it.
      enabled: true

  TIMER:
    A: # Game Speed / Balance. Detects if the client is sending packets faster than the server.
      enabled: true

  SPOOF:
    A: # Ground Spoof. Detects clients claiming to be on the ground while in mid-air.
      enabled: true

  # ------------------------------------------------------------------------------- #
  # COMBAT CHECKS
  # ------------------------------------------------------------------------------- #
  AIM:
    A: # Sensitivity/Grid (GCD). Detects robotic/generated aim (Aimbot/KillAura).
      enabled: true
    B: # Rotation Acceleration. Detects perfectly smooth or instantly snapping aim.
      enabled: true

  HITBOX:
    A: # Reach. Detects hitting entities from too far away.
      enabled: true
    B: # Field of View (FOV). Detects hitting entities outside the player's vision/angle.
      enabled: true

  RAYCAST:
    A: # Wall Hit. Detects hitting entities through solid blocks (walls).
      enabled: true

  # ------------------------------------------------------------------------------- #
  # WORLD / BUILDING CHECKS
  # ------------------------------------------------------------------------------- #
  SCAFFOLD:
    A: # Face Check. Placing blocks on faces that shouldn't be visible.
      enabled: true
    B: # Vector Check. Invalid placement coordinates.
      enabled: true
    C: # Sprint Check. Placing blocks backwards while sprinting forward.
      enabled: true
    D: # Impossible Place. Towering down or sprinting while bridging without looking down.
      enabled: true
    E: # Fast Place. Placing blocks immediately after switching items (AutoBlock).
      enabled: true
    F: # Rotation check. Pitch stability analysis while bridging.
      enabled: true
    G: # GCD Aim Analysis. Detects robotic rotations specifically during bridging.
      enabled: true
    H: # Cadence. Detects consistent placement timing (FastPlace/Macro).
      enabled: true
    I: # Raytrace Alignment. Ensures the player is physically looking at the block face they clicked.
      enabled: true
    J: # Rotation Lock. Detects identical rotations between placements.
      enabled: true

  # ------------------------------------------------------------------------------- #
  # PACKET / PROTOCOL CHECKS
  # ------------------------------------------------------------------------------- #
  BAD_PACKET:
    A: # Invalid Pitch. Head pitch > 90 or < -90 (Derp).
      enabled: true
    B: # Slot Switch. Switching to the same slot twice.
      enabled: true
    C: # Payload. Detects crash exploits via CustomPayload packets.
      enabled: true
    D: # Impossible Action. Sprinting while Blind or Hungry (OmniSprint).
      enabled: true


================================================================================
FILE PATH: .\src\main\resources\plugin.yml
================================================================================


name: TruthfulAC
version: 'v1.2'
main: ret.tawny.truthful.TruthfulPlugin
api-version: '1.21'
author: Tawny
description: Multi-version anti-cheat with modernized movement and combat checks
load: POSTWORLD
depend:
  - ProtocolLib
commands:
  truthful:
    description: Main command for Truthful Anti-Cheat
    usage: /truthfulac <help|logs|exempt|menu>
    aliases: [TruthfulAC, ac]
    permission: truthful.admin
permissions:
  truthful.admin:
    description: Admin permission for Truthful
    default: op
  truthful.alerts:
    description: Receive alerts
    default: op
